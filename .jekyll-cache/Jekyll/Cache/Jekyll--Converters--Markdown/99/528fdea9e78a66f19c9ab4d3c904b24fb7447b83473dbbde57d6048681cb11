I"t<p><br /></p>

<h2 id="1-배열의-포인터-변환">1. 배열의 포인터 변환</h2>

<p>배열을 포인터로 변환하여 주소 값 이동을 통해 쉽게 배열의 값을 접근 할 수 있다. 
다음 예제를 통해서 그 기능을 살펴 볼 수 있다.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span> 
	<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>이 둘의 결과는 같다는 것을 알 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2
2
</code></pre></div></div>

<h2 id="2-명시적-형변환">2. 명시적 형변환</h2>

<p>C에서는 타입 캐스트 (type cast)를 통해서 형변환을 하게 된다. C++ 및 모던 C++에서도 같은 기능을 확장 재공하는 것 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cast-name&lt;type&gt;(expression)

* type 변환될 형
* expresssion 변환할 값
* cast-name static_cast, const_static, dynamic_cast, reinterpret_cast
</code></pre></div></div>

<h3 id="21-static_cast-형변환">2.1 static_cast 형변환</h3>

<p>보통 산술연산 작업에서 정밀도가 변경되는 것을 방지하기 위한 강제 형변환하는 경우 활용되는 것 같다.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kt">float</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">100.12345</span><span class="p">;</span>
	<span class="kt">double</span> <span class="n">j</span> <span class="o">=</span> <span class="mf">200.12345</span><span class="p">;</span>

	<span class="kt">float</span> <span class="n">count</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>위 예제를 통해서 개발자의 실수로 정밀도가 변경되는 것을 방지하기 위해서 <code class="highlighter-rouge">static_cast</code>가 활용되었다는 것을 알 수 있다.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">1212</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>
	<span class="kt">double</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span> <span class="o">*&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="3-void-포인터">3. void 포인터</h2>

<p>C++ 11 표준 부터 재미있는 포인터의 개념들이 나오기 시작했다. void 포인터는 참조자변수의 타입을 지정하지 않아도 auto와 같이 자동으로 할당해주는 기능을 갖추고 있다. 기존의 C언어는 노가다 성이 짙었는데, 모던 C++은 더 편리해진 느낌이다.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">doble</span> <span class="n">value2</span> <span class="o">=</span> <span class="mf">100.121</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">voidPtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">;</span>
<span class="n">voidPtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">value2</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>[출처:최신 표준 C++로 쉽고 빠르게 안내하는 모던 C++ 프로그래밍]</p>
:ET