<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-12-12T07:36:19+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">로봇을 배우기 위한 지식 창고</title><subtitle>로봇을 배우기 위한 지식 창고</subtitle><author><name>Kiho Lee</name></author><entry><title type="html">06.GIT 파일 트랙킹 중지 및 재시작</title><link href="http://localhost:4000/categories/git/GIT-06-git-tracking-abort.html" rel="alternate" type="text/html" title="06.GIT 파일 트랙킹 중지 및 재시작" /><published>2019-12-12T00:00:00+00:00</published><updated>2019-12-12T00:00:00+00:00</updated><id>http://localhost:4000/categories/git/GIT-06-git-tracking-abort</id><content type="html" xml:base="http://localhost:4000/categories/git/GIT-06-git-tracking-abort.html">&lt;h2 id=&quot;1-들어가며&quot;&gt;1. 들어가며&lt;/h2&gt;

&lt;p&gt;git을 쓰면서 트랙킹되고 있는 파일 즉, git의 인덱스에 등록된 파일을 &lt;strong&gt;.gitignore&lt;/strong&gt;로 등록해도 작동이 안되는 경우가 있다. 사실 gitignore와 다른 개념이기 때문에 이 명령어가 작동 안되는 것이다.&lt;/p&gt;

&lt;p&gt;지금같은 경우는 &lt;code class=&quot;highlighter-rouge&quot;&gt;로컬에 파일은 있지만, 이 파일을 리모트로 올리지 않겠다(리모트는 있으면 삭제됨)&lt;/code&gt;가 아니라, &lt;code class=&quot;highlighter-rouge&quot;&gt;로컬의 파일과 리모트의 파일의 내용을 다르게 유지하고 싶은 경우&lt;/code&gt;에 해당한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 쓰면, 기존에 해당 폴더에 있는 모든 파일과 하위 폴더 내용이 모두 git index에 등록이 된다.&lt;/p&gt;

&lt;p&gt;그래서 우리는 .gitignore라는 파일을 활용하게 되는데, 이미 등록이 된 경우 인덱스에서 빠져나오지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;2-gitignore-만들기-참고&quot;&gt;2. .gitignore 만들기 (참고)&lt;/h2&gt;

&lt;p&gt;이 경우는 사실 로컬 디렉토리에는 존재하는 파일이지만, 리모트(github)에는 올리고 싶지 않은 *.log파일이나 기타 파일들에 해당할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로컬 &lt;strong&gt;.gitignore&lt;/strong&gt;를 만듭니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;저장소에 &lt;strong&gt;.gitignore&lt;/strong&gt; 라는 파일을 생성하면 Git은 커밋하기 전에 파일을 사용하여 무시할 파일과 디렉토리를 결정한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.gitignore&lt;/strong&gt;의 파일은 저장소로 &lt;strong&gt;git add&lt;/strong&gt;를 수행할 때, 추적하지 않고, &lt;strong&gt;git commit&lt;/strong&gt;을 통해 인덱싱 되지 않고, &lt;strong&gt;git push&lt;/strong&gt;를 통해 리모트 리포지토리에도 저장되지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;1-터미널에서-git-저장소의-위치로-이동&quot;&gt;(1) 터미널에서 Git 저장소의 위치로 이동&lt;/h3&gt;
&lt;h3 id=&quot;2-gitignore-파일-생성&quot;&gt;(2) .gitignore 파일 생성&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ touch .gitignore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파일이 이미 체크인되어 있고 무시하려는 경우 나중에 규칙을 추가해도 Git 은 파일을 무시하지 않는다. 이 경우 터미널에서 다음 명령을 실행하여 파일을 먼저 추적 해제해야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rm --cached FILENAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 하면 git index에서 파일이 삭제되고, 디스크 상에 파일은 존재한다. 이후  commit과 push를 하면, 리모트에 존재하는 파일도 사라지게 된다.&lt;/p&gt;

&lt;p&gt;[출처]&lt;a href=&quot;https://help.github.com/en/github/using-git/ignoring-files&quot;&gt;GitHub Help&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-리모트-파일과-로컬-파일-다르게-유지하기&quot;&gt;3. 리모트 파일과 로컬 파일 다르게 유지하기&lt;/h2&gt;

&lt;p&gt;작업을 하다보면, 서버로 올라가서 작동하는 파일이 개발자가 로컬에서 테스트하는 환경과 다르게 유지해야 되는 경우가 비일비재하다.
그럴 경우, 로컬에서 파일을 테스트하고 올리기 전에 세팅파일을 변경해서 커밋하는 번거로움을 중단하고, git index에서 추적을 중단시켜 놓는 방법이 있다. 즉, git의 index에서 파일 트래킹을 중지 시키는 것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git update-index --assume-unchanged &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 다시 트랙킹이 필요할 경우 아래 명령어로 트래킹 유지로 복구 시킬 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git update-index --no-assume-unchanged &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 폴더 자체를 트래킹 중지를 하고자 하면,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git ls-files -z .settings | xargs -0 git update-index --assume-unchanged
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[출처]&lt;a href=&quot;https://seotory.tistory.com/5&quot;&gt;seotory&lt;/a&gt;&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="GIT" /><category term="트래킹중지" /><category term="트래킹재시작" /><summary type="html">1. 들어가며</summary></entry><entry><title type="html">05.ROS 용어 정리 및 개념</title><link href="http://localhost:4000/categories/ros/ROS-05-ros-words.html" rel="alternate" type="text/html" title="05.ROS 용어 정리 및 개념" /><published>2019-12-10T00:00:00+00:00</published><updated>2019-12-10T00:00:00+00:00</updated><id>http://localhost:4000/categories/ros/ROS-05-ros-words</id><content type="html" xml:base="http://localhost:4000/categories/ros/ROS-05-ros-words.html">&lt;h2 id=&quot;1-ros-란&quot;&gt;1. ROS 란?&lt;/h2&gt;

&lt;p&gt;ROS는 로봇의 응용프로그램을 개발하기 위한 운영체제와 같은 로봇 소프트웨어 플랫폼이다. ROS는 로봇 응용프로그램을 개발할 때 필요한 하드웨어 추상화, 디바이스 제어, 센싱 및 인식, SLAM 등 다양한 기능을 라이브러리 형태로 제공하고 있으며, 디버깅 도구 및 시뮬레이션 도구를 제공하는 메타 OS이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_communication.png&quot; title=&quot;ROS 개념&quot; /&gt;
출처:&lt;a href=&quot;https://robertchoi.gitbook.io/ros/untitled-2&quot;&gt;ROS 하루에 입문하기&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;메타 OS는 사실 실제로 존재하는 말이기 보다는 ROS를 설명하기 위해서 등장한 용어라고 보여진다. Linux, Windos, OS X와 같은 다른 운영체제간 통신을 기반으로 이기종 디바이스 컨트롤이 가능하게 만든 것이 ROS이기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-마스터&quot;&gt;2. 마스터&lt;/h2&gt;

&lt;p&gt;마스터(master)란 노드와 노드사이를 연결하여 메시지 통신이 가능하게 하는 일종의 커멘드 센터이다. 흔히 네임 서버로 비교하여 설명을 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roscore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어를 실행하여 마스터를 실행하고, 각각의 패키지 노드들을 연결하여 ROS프로그램이 동작하게 된다.
또한, 마스터는 마스터에 접속한 슬레이브들과의 접속상태를 지속적으로 유지하는 것이 아니라 HTTP기반의 프로토콜인 XMLRPC(XML-Remote Procedure Call)를 이용하여 슬레이브들과 통신한다.&lt;/p&gt;

&lt;p&gt;로봇은 매우 복잡한 센서와 모듈들이 통합되어 있어서, 통신을 지속적으로 연결하고 있으면 리소스의 낭비가 심각해질 수 있지만, 이러한 통신 방식은 자원을 효율적으로 활용할 수 있도록 돕니다. 게다가 XMLRPC는 매우 가볍고, 다양한 프로그래밍 언어를 지원하기 때문에 여러 종류의 하드웨어와 언어를 지원해야 하는 ROS에 매우 적합하다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;설정시 유의해야 할 점은 ROS를 구동하면서 마스터는 사용자가 정해 놓은 ROS_MASTER_URI 변수에 기재된 URI 주소와 포트를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_communication3.jpeg&quot; title=&quot;ROS 통신 개념&quot; /&gt;
출처:&lt;a href=&quot;https://robertchoi.gitbook.io/ros/untitled-2&quot;&gt;ROS 하루에 입문하기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-노드&quot;&gt;3. 노드&lt;/h2&gt;

&lt;p&gt;노드(node)는 ROS에서 실행되는 최소 단위의 프로세서를 지칭한다. 즉, 최소 단위의 실행 가능한 프로그램으로 반드시 roscore가 등록된 이후에 실행을 시켜야 한다.
모든 프로그램에서 권장하는 방법이겠지만, 프로그램을 모듈단위로 잘 구성하여 재사용성을 높이도록 하는 것이 좋은 노드를 구성하는 방법이 될 것이다. 예를 들면, 로봇을 구동하기 위해서 필요한 모터와 엔코더 등을 각각 세분화하여 노드로 구성하는 것을 권장한다.&lt;/p&gt;

&lt;p&gt;노드에는 다양한 정보가 들어간다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;노드 명칭&lt;/li&gt;
  &lt;li&gt;퍼블리셔(Publisher), 서브스크라이버(Subscriber), 서비스 서버(Service server), 서비스 클라이언트(Service Client) 구분&lt;/li&gt;
  &lt;li&gt;사용되는 토픽 및 서비스 이름&lt;/li&gt;
  &lt;li&gt;메시지 형태&lt;/li&gt;
  &lt;li&gt;URI 주소&lt;/li&gt;
  &lt;li&gt;포트 번호 등&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;노드는 마스터와 통신할 때 XMLRPC를 활용하고, 노드간에도 XMLRPC 혹은 TCP/IP 통신 방식을 활용한 TCPROS를 이용한다.&lt;/p&gt;

&lt;h2 id=&quot;4-패키지&quot;&gt;4. 패키지&lt;/h2&gt;

&lt;p&gt;패키지(Package)는 ROS를 구성하는 기본 단위가 된다. 
ROS의 응용프로그램은 패키지 단위로 개발되며 패키지는 최소한 하나 이상의 노드를 포함하거나 다른 패키지의 노드를 싱행하기 위한 설정파일 및 의존성 라이브러리, 데이터 셋 등이 있을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;5-메타패키지&quot;&gt;5. 메타패키지&lt;/h2&gt;

&lt;p&gt;메타패키지(metapackage)는 공통된 목적을 가진 패키지 집합이다. 대단위 기능을 수행하는 프로그램의 경우 단일 패키지로 불가능하고 복수 개의 패키지를 연동 실행하여 수행 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;6-메시지&quot;&gt;6. 메시지&lt;/h2&gt;

&lt;p&gt;노드는 메시지(message)를 통해 노드 간의 데이터를 주고 받을 수 있다. 메시지의 종류는 integer, floating point, boolean과 같은 변수 형태에서 메시지를 품은 메시지이거나 배열도 메시지로 송수신이 가능하다.&lt;/p&gt;

&lt;p&gt;메시지의 통신 방식은 TCPROS, UDPROS 등의 방식이 있다.&lt;/p&gt;

&lt;p&gt;단방향 메시지 송수신 방식을 토픽(Topic)이라고 한다.
양방향 메시지 송수신 방식을 서비스(Service)라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;7-토픽&quot;&gt;7. 토픽&lt;/h2&gt;

&lt;p&gt;토픽(topic)은 로봇 혹은 로봇 연관 시스템에서 작업을 수행하기 위한 작업 내용(ROS프로그래밍 책에서는 ‘이야깃거리’라 칭함)을 말한다고 보면 된다. 퍼블리셔(Publisher) 노드가 하나의 작업 내용에 대해 마스터에 등록한 후, 이 작업 내용에 대한 메시지를 퍼블리시(출판 혹은 발송)하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_topic.jpeg&quot; title=&quot;토픽 개념&quot; /&gt;
출처:&lt;a href=&quot;https://robertchoi.gitbook.io/ros/untitled-2&quot;&gt;ROS 하루에 입문하기&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;용어나 말이 굉장히 낯설게 느껴질 수 있다. ROS를 설계자가 나름 통신 프로토콜(일종의 통신 약속)을 규정하기 위해서 들고 나온 개념이라고 보면 된다. 이러한 용어는 자주 보고 쓰다보면 익숙해질 수 있을 것이라고 생각한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 작업 내용을 구독해주시는 열혈 독자가 있는데, 이를 서브스크라이버(subscriber)라고 한다. 각각 노드별로 역할이 있고,명칭이 있다고 보면된다.&lt;/p&gt;

&lt;h2 id=&quot;8-퍼블리시-및-퍼블리셔&quot;&gt;8. 퍼블리시 및 퍼블리셔&lt;/h2&gt;

&lt;p&gt;퍼블리시(publish)는 작업 내용에 해당하는 토픽의 메시지 형태의 데이터를 발송(송신)하는 것을 말한다. 퍼블리셔(publisher)는 이러한 퍼블리시(publish)라는 행위를 하는 노드를 말한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;골키퍼가 공을 잡고, 다른 선수들은 공을 발로 찬다. 이렇게 하면 말이 되지만, 공격수가 공을 잡는다 하면 말도 안되는 행위가 될 것이다. 머 이렇게 일단 이해해보자. 사실 어려운 내용도 아니니 말이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;퍼블리셔는 자신의 노드 정보와 토픽으로 보낼 정보 등을 마스터 ROSCORE에 등록한다. 그리고 subscriber를 할 노드에게 메시지를 보낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_publisher.png&quot; title=&quot;퍼블리셔 개념&quot; /&gt;
&lt;br /&gt;
출처:&lt;a href=&quot;https://m.blog.naver.com/PostView.nhn?blogId=0323lena&amp;amp;logNo=220357703221&amp;amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F&quot;&gt;김빠진사이다&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;9-서브스크라이브-및-서브스크라이버&quot;&gt;9. 서브스크라이브 및 서브스크라이버&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;야구에 투수가 있으면, 당연히 포수가 있고, 타자도 있다. 그렇지만, 토픽(TOPIC)의 개념에서 보면 투수와 포수만 있다고 볼 수 있다. 야구공은 메시지라고 볼 수 있을 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_subscriber.png&quot; title=&quot;서브스크라이버 개념&quot; /&gt;
&lt;br /&gt;
출처:&lt;a href=&quot;https://wyvernsstory.tistory.com/entry/%EA%B3%B5%EA%B0%90%E5%85%B1%E6%84%9F-W-%EC%95%BC%EA%B5%AC%EC%9E%A5%EC%97%90%EC%84%9C-%EA%B7%B8%EB%A6%AC%EB%8A%94-%EB%82%98%EC%9D%98-%EB%AF%B8%EB%9E%98-SK-%ED%8F%AC%EC%88%98-%EC%9D%B4%EC%9C%A4%EC%9E%AC&quot;&gt;sk와이번스&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;서브스크라이버는 퍼블려서와 같은 프로세스를 따른다. 먼저 마스터에 자신의 정보를 등록하고, 서브스크라이브를 수행하기 위한 토픽을 포함한 자신의 정보들을 등록하고, 해당 토픽을 퍼블리시하는 퍼블리셔 노드의 정보를 마스터로 부터 받게 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;야구를 예로 들어서 설명을 하지만, 다수의 퍼블리셔가 있을 수 있고, 다수의 서브스크라이버가 있을 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;토픽 개념의 통신방식(퍼블리시와 서브스크라이브)은 비동기 방식이라서 전송이 필요할 때만, 데이터를 보낼 수 있기 때문에 매우 효율적인 방식이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;보통 센서로부터 데이터를 받을 때, 패시브한 방식으로 데이터를 받기만 한다. 물론 일부 I2C 통신으로 COMMAND를 날리는 센서도 있긴 하지만, 대부분의 패시브 센서 (온도, 습도, 조도 등)는 데이터를 보내는 핀(Tx)만 활용하기 때문에 이러한 센서는 토픽 방식을 쓰면 매우 효율적이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;10-서비스service&quot;&gt;10. 서비스(service)&lt;/h2&gt;

&lt;p&gt;서비스(service)는 작업 내용(특수 목적 포함)에 대해 서비스 클라이언트(service client)와 서비스 서버(service server)간의 양방향 동기적 통신을 말한다. 클라이언트는 요청하고, 서버는 응답하게된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;흔히 대화를 주고 받는 만담(conversation)과는 좀 다르다고 볼 수 있는데, 작업 내용에 대한 메시지를 보내고 그 결과를 주는 형식이라고 보면 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_service.jpeg&quot; title=&quot;서비스 개념&quot; /&gt;
출처:&lt;a href=&quot;https://robertchoi.gitbook.io/ros/untitled-2&quot;&gt;ROS 하루에 입문하기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-서비스-서버service-server&quot;&gt;11. 서비스 서버(service server)&lt;/h2&gt;

&lt;p&gt;서비스 서버(service server)는 서비스 클라이언트(service client)로 부터 작업 내용의 요청(메시지;request)를 받고, 작업을 한 후에 작업 내용의 완료결과(메시지)를 응답(메시지;response)하게 된다. 따라서, 서비스 서버가 응답 주체(노드)가 된다.&lt;/p&gt;

&lt;h2 id=&quot;12-서비스-클라이언트service-client&quot;&gt;12. 서비스 클라이언트(service client)&lt;/h2&gt;

&lt;p&gt;서비스 클라이언트(service client)는 작업 내용의 요청(메시지;request)을 서비스 서버(service server)로 보내고 그 결과 응답(메시지;response)를 받는 요청 주체(노드)가 된다.&lt;/p&gt;

&lt;h2 id=&quot;13-액션action&quot;&gt;13. 액션(action)&lt;/h2&gt;

&lt;p&gt;액션(action)은 서비스처럼 양방향을 통신방식이지만, 중간 중간에 작업 상황을 피드백을 해주는 처리가 들어간 통신 방식이라고 할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;파일을 옮기기 하면, 파일이 이동하는 Progress bar가 보인다. 이러한 기능도 액션의 개념과 유사하다고 볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;액션도 서비스와 비슷한 면이 있지만, 요청과 응답을 달리 표현한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;목표(goal)&lt;/li&gt;
  &lt;li&gt;결과(result)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;액션의 목표를 정하는 액션 클라이언트(action client)와 목표에 따라 임무를 수행하고, 임무가 끝나기 전까지 계속 피드백을 보내는 액션 서버(action server)가 서로 비동기 양방향 통신을 하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;14-액션-서버action-server&quot;&gt;14. 액션 서버(action server)&lt;/h2&gt;

&lt;p&gt;액션 서버(action server)는 앞서 설명한 바와 같이 액션 클라이언트로 부터 목표를 전달 받고, 해당 목표를 수행하는 노드(주체)가 된다. 또한, 목표(임무)를 완료하기 전까지 중간 중간 액션 클라이언트로 부터 받은 목표에 맞게 피드백을 보내주게 된다.&lt;/p&gt;

&lt;h2 id=&quot;15-액션-클라이언트action-client&quot;&gt;15. 액션 클라이언트(action client)&lt;/h2&gt;

&lt;p&gt;액션 클라이언트(action client)는 목표를 출력하고, 액션 서버에서 보내는 결과와 피드백을 입력받는 노드이다. 액션 클라이언트가 목표를 액션 서버에 보내고 피드백을 받다가 취소명령을 보낼 수 있고, 완료 메시지를 액션 서버로부터 받으면 다음 명령을 보낼 수도 있다.&lt;/p&gt;

&lt;h2 id=&quot;16-파라미터&quot;&gt;16. 파라미터&lt;/h2&gt;

&lt;p&gt;ROS에서 parameter(매개변수)는 보통 노드에서 활용되는 파라미터를 말하게 된다. 예를 들면, 윈도우에서 활용되는 &lt;strong&gt;*.ini&lt;/strong&gt;파일이라고 볼 수도 있을 것 같다.
보통은 디폴트(default) 값을 활용하게 되는 데, 상황에 따라 외부에서 설정 값을 밀어 넣을 수 있기 때문에 실시간 변경이 매우 용이하고 유용한 기능이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;외부 장치와 연결되는 USB포트, 카메라 캘리브레이션 값, 모터 속도 등등&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;17-파라미터-서버&quot;&gt;17. 파라미터 서버&lt;/h2&gt;

&lt;p&gt;파라미터 서버(parameter server)는 패키지에서 파라미터를 사용할 때, 이 곳에 등록하여 활용한다. 이는 마스터의 기능 중 하나이기도 하다.&lt;/p&gt;

&lt;h2 id=&quot;18-catkin&quot;&gt;18. Catkin&lt;/h2&gt;

&lt;p&gt;캐킨(Catkin)은 ROS의 빌드 시스템이다. ROS의 빌드 시스템은 기본적으로 CMake(Cross Platform Make)를 이용하고 있어서 패키지 폴더에 CMakeLists.txt라는 파일에 빌드를 하기 위한 다양한 설정 내용들을 작성해야 한다. ROS에서 CMake를 ROS에 맞게 변경하여 ROS만의 특ㄹ화된 Catkin Build System을 구축하였다.
캐킨 빌드 스스템은 ROS와 관련된 빌드, 패키지 관리, 패키지 간의 의존관계 등을 편리하게 사용할 수 있게 한다.&lt;/p&gt;

&lt;h2 id=&quot;19-roscore&quot;&gt;19. roscore&lt;/h2&gt;

&lt;p&gt;roscore는 ROS 마스터를 실행하는 명령어이다. 같은 네트워크라면 다른 컴퓨터에서 실행해도 된다. ROS2는 기본적으로 멀티네트워크를 지원한다고 하지만, ROS는 roscore와 같은 네트워크 상에 있어야 통신이 가능하다.&lt;/p&gt;

&lt;p&gt;네트워크 설정은 환경설정 파트에서 했던 부분의 IP주소를 참조하면 된다.&lt;/p&gt;

&lt;p&gt;기존에 설정했던 내용&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# Set ROS Network&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ROS_HOSTNAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;192.168.0.44
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ROS_MASTER_URI&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;ROS_HOSTNAME&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;:11311
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;만약 특별한 설정이 없으면, localhost를 활용하게 되고, 포트번호는 11311을 활용하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_communication2.jpeg&quot; title=&quot;ROS 통신 개념&quot; /&gt;
출처:&lt;a href=&quot;https://robertchoi.gitbook.io/ros/untitled-2&quot;&gt;ROS 하루에 입문하기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;20-rosrun&quot;&gt;20. rosrun&lt;/h2&gt;

&lt;p&gt;rosrun은 ROS의 기본 실행 명령어이다. 패키지에서 하나의 노드를 실행할 때 사용하게 된다. 
거북이 움직이는 테스트를 해본 경험이 있다면 아래 명령어를 기억할 것이다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rosrun turtlesim turtlesim_node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;노드는 실행되면서 ROS_HOSTNAME에 URI의 주소를 활용하게 되고, 포트번호는 임의로 지정되게 된다.&lt;/p&gt;

&lt;h2 id=&quot;21-roslaunch&quot;&gt;21. roslaunch&lt;/h2&gt;

&lt;p&gt;ROS를 조금이라도 실행해 본 사람이라면, 알겠지만 굉장히 많은 터미널 창을 열어두어야 할 것이다. 만약 여러 노드를 실행한다면, 해당하는 노드만큼 터미널을 실행해야 될테지만, 만약 한 번에 많은 노드를 실행한다면 상당히 피로도 높은 작업이 될 수 있다.
roslaunch는 여러 노드를 실행하는 개념이라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;– 지원 옵션 –&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;복수 개의 노드 실행&lt;/li&gt;
  &lt;li&gt;패키지 파라미터 설정&lt;/li&gt;
  &lt;li&gt;노드 이름 변경&lt;/li&gt;
  &lt;li&gt;노드 네임스페이스 설정&lt;/li&gt;
  &lt;li&gt;ROS_ROOT 및 ROS_PACKAGE_PATH 설정&lt;/li&gt;
  &lt;li&gt;환경변수 변경&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;roslaunch의 실행 내용은 *.launch 파일을 사용하여 실행 노드에 대한 설정을 해주는데 XML(Extensible Markup Language)을 이용해서 옵션을 설정하게된다.&lt;/p&gt;

&lt;h2 id=&quot;22-bag&quot;&gt;22. bag&lt;/h2&gt;

&lt;p&gt;ROS에서 매우 중요한 기능중에 하나로 보여지는 bag은 메시지를 저장한 파일 포맷(*.bag)이다. 이 파일을 이용하여 로봇을 활용한 테스트 상황을 구현할 수 있다. 그러면 실제 실험환경을 재구축 하지 않아도 &lt;strong&gt;rosbag play *.bag&lt;/strong&gt;를 이용해서 센서의 값들을 확인해 볼 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;rosbag의 기록, 재생의 기능을 활용하면 반복되는 프로그램 수정이 많은 알고리즘 개발에 매우 유용하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;23-ros-wiki&quot;&gt;23. ROS Wiki&lt;/h2&gt;

&lt;p&gt;ROS에 관련된 개념과 활용방법에 대하여 설명을 제공하는 위키 기반(&lt;strong&gt;http://wiki.ros.org&lt;/strong&gt;)의 페이지이다. ROS에 관련된 강좌나 책을 찾아보는 것도 좋지만, 가장 기본이 되는 메뉴얼은 ROS Wiki이다.&lt;/p&gt;

&lt;h2 id=&quot;24-리포지토리&quot;&gt;24. 리포지토리&lt;/h2&gt;

&lt;p&gt;공개 패키지는 ROS Wiki에서 리포지토리의 주소를 명시하고 있다. 리포지토리는 패키지가 저장된 웹상의 URL이며, svn, hg, git 등의 소스 관리 시스템을 이요하여 이슈, 개발, 내려받기 등을 관리하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;25-그래프&quot;&gt;25. 그래프&lt;/h2&gt;

&lt;p&gt;ROS에서 실행한 다양한 노드와 통신 관계(토픽, 서비스, 액션)을 그래프(graph)로 시각화하여 직관적으로 관계를 파악 할 수 있도로 돕는 시각화 도구이다.&lt;/p&gt;

&lt;h2 id=&quot;26-네임&quot;&gt;26. 네임&lt;/h2&gt;

&lt;p&gt;노드, 파라미터, 토픽, 서비스, 액션 등 모두 네임(name)을 갖고 있고, 이를 활용하게 된다. 각 네임은 ROS 마스터에 등록하고, 통신을 할 때 이름을 기반으로 검색하거나 메시지를 전송하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;27-클라이언트-라이브러리&quot;&gt;27. 클라이언트 라이브러리&lt;/h2&gt;

&lt;p&gt;ROS는 개발 언어의 의존성을 줄이기 위한 방법으로 클라이언트 라이브러리(client library)로 각종 언어의 개발환경을 제공하고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt; - roscpp&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Python&lt;/strong&gt; - rospy&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Lips&lt;/strong&gt; - roslips&lt;/li&gt;
  &lt;li&gt;Java - rosjava&lt;/li&gt;
  &lt;li&gt;Lua - roslua&lt;/li&gt;
  &lt;li&gt;.NET - roscs&lt;/li&gt;
  &lt;li&gt;EusLisp - roseus&lt;/li&gt;
  &lt;li&gt;R - rosR&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;28-uri&quot;&gt;28. URI&lt;/h2&gt;

&lt;p&gt;URI(Uniform Resource Identifier, 통합 자원 식별자)는 인터넷에 있는 자원을 나타내는 유일한 주소이다.&lt;/p&gt;

&lt;h2 id=&quot;29-md5&quot;&gt;29. MD5&lt;/h2&gt;

&lt;p&gt;MD5(Message-Digest algorithm 5)는 128bit 암호화 해시 함수이다. 주로 프로그램이나 파일이 송신된 원본과 같은지 무결성을 검사하기 위해서 활용된다.&lt;/p&gt;

&lt;h2 id=&quot;30-rpc&quot;&gt;30. RPC&lt;/h2&gt;

&lt;p&gt;RPC(Remote Procedure Call)란 &lt;strong&gt;원격 컴퓨터의 프로그램이 다른 컴퓨터에 있는 서브 프로그램(Procedure)을 불러내는(Call) 것&lt;/strong&gt;을 의미한다. TCP/IP, IPX 등의 전송 프로토콜 기술을 활용한다.&lt;/p&gt;

&lt;h2 id=&quot;31-xml&quot;&gt;31. XML&lt;/h2&gt;

&lt;p&gt;XML(Extensible Markup Language)은 W3C에서 다른 특수 목적의 마크텁 언어를 만드는 용도로 권장하는 다목적 마크업 언어(markup language)이다.
ROS에서 *.launch, *.urdf, package.xml 등 다양한 부분에서 사용되고 있다.&lt;/p&gt;

&lt;h2 id=&quot;32-xmlrpc&quot;&gt;32. XMLRPC&lt;/h2&gt;

&lt;p&gt;XMLRPC(XML-Remote Procedure Call)는 RPC 프로토콜의 일종으로, 인코딩 형식에서는 XML을 채택하고, 전송방식은 접속상태를 유지하지 않고 점검하지 않는 요청과 응답 방식의 HTTP 프로토콜을 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;33-tcpip&quot;&gt;33. TCP/IP&lt;/h2&gt;

&lt;p&gt;TCP(Transmission Control Protocol)는 전송 제어 프로토콜이다.
인터넷 프로토콜 계층으로 보면 IP(Internet Protocol)를 기반으로 전송 제어 프로토콜인 TCP를 사용하여 데이터의 전달을 보증하고 보낸 순서대로 송수신한다.&lt;/p&gt;

&lt;p&gt;TCPROS 메시지 및 서비스에서 사용되는 TCP/IP 기반의 메시지 방식을 TCPROS라고 하고 UDPROS는 UDP기반이다.&lt;/p&gt;

&lt;h2 id=&quot;34-cmakeliststxt&quot;&gt;34. CMakeLists.txt&lt;/h2&gt;

&lt;p&gt;ROS의 빌드 시스템인 Catkin은 기본적으로 CMake를 이용하고 있고, CMakeLists.txt는 빌드를 할 데이터의 빌드 환경을 기술하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;35-packagexml&quot;&gt;35. package.xml&lt;/h2&gt;

&lt;p&gt;패키지의 정보를 담은 XML 파일로 패키지의 이름, 저작권, 라이선스, 의존성 패키지 등을 기술하고 있다.&lt;/p&gt;

&lt;p&gt;출처:[ROS 로봇프로그래밍 저)표윤석, 조한철, 정려운, 임태훈]&lt;/p&gt;

&lt;h2 id=&quot;36-tftranform&quot;&gt;36. TF(Tranform)&lt;/h2&gt;

&lt;p&gt;구동하는 로봇의 각 조인트(joint)들의 상대좌표 변환으로 물리적 이미지를 표현
트리(tree) 형태로 조인트들 간의 관계도를 표시함&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_TF.jpeg&quot; title=&quot;TF 개념&quot; /&gt;
출처:&lt;a href=&quot;https://robertchoi.gitbook.io/ros/untitled-2&quot;&gt;ROS 하루에 입문하기&lt;/a&gt;&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="ROS" /><category term="words" /><category term="concept" /><summary type="html">1. ROS 란?</summary></entry><entry><title type="html">02.C++ IDE Eclipse 설치하기</title><link href="http://localhost:4000/categories/c++/CPP-02-install-eclipse.html" rel="alternate" type="text/html" title="02.C++ IDE Eclipse 설치하기" /><published>2019-12-08T22:17:13+00:00</published><updated>2019-12-08T22:17:13+00:00</updated><id>http://localhost:4000/categories/c++/CPP-02-install-eclipse</id><content type="html" xml:base="http://localhost:4000/categories/c++/CPP-02-install-eclipse.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;eclipse-ide-for-cc-developers&quot;&gt;Eclipse IDE for C/C++ Developers&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-자바-jdk-설치하기&quot;&gt;1. 자바 JDK 설치하기&lt;/h2&gt;

&lt;p&gt;사용 가능한 표준 설치 유형은 JDK와 JRE입니다. JDK (Java Development Kit)는 Java 컴파일러를 포함하여 새로운 Java 응용 프로그램을 개발할 수있는 기능을 제공합니다. JRE (Java Runtime Environment)는 애플릿이있는 Java 응용 프로그램에 대한 런타임 환경을 제공합니다. Java 개발자는 새로운 Java 응용 프로그램을 만들려면 시스템에 JDK와 JRE를 모두 설치해야했습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;중요 : Oracle Java 8은 더 이상 공개적으로 다운로드 할 수 없습니다. 아래 링크를 사용하여 Java 11을 설치할 수 있습니다.이 자습서를 계속 진행하여 OpenJDK 8을 설치할 수도 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 튜토리얼을 사용하여 PPA를 사용하여 Ubuntu 19.10, 18.04 LTS, 16.04 LTS, LinuxMint 19, 18에 OpenJDK Java 8을 설치하십시오. 명령 행을 통해 Ubuntu에 Java 8을 설치하려면 아래 단계를 따르십시오.&lt;/p&gt;

&lt;h3 id=&quot;1-단계--우분투에-java-8-설치&quot;&gt;1 단계 – 우분투에 Java 8 설치&lt;/h3&gt;

&lt;p&gt;OpenJDK 8은 기본 Apt 저장소에서 사용 가능합니다. 다음 명령을 사용하여 Ubuntu 시스템에 Java 8을 간단히 설치할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Ubuntu 및 LinuxMint에 Java 8을 설치하려면 아래 명령을 실행하십시오.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt update
$ sudo apt install openjdk-8-jdk openjdk-8-jre
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-단계--java-이탈-레이션-확인&quot;&gt;2 단계 – Java 이탈 레이션 확인&lt;/h3&gt;

&lt;p&gt;위의 단계를 사용하여 Oracle Java 8을 성공적으로 설치 한 후 다음 명령을 사용하여 설치된 버전을 확인하십시오.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ java -version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-단계--java_home-및-jre_home-변수-설정&quot;&gt;3 단계 – JAVA_HOME 및 JRE_HOME 변수 설정&lt;/h3&gt;

&lt;p&gt;Linux 시스템에 Java를 설치 한 후 JAVA_HOME 및 JRE_HOME 환경 변수 를 설정해야합니다. JAVA_HOME 및 JRE_HOME 환경 변수는 많은 Java 응용 프로그램에서 런타임 중에 Java 라이브러리를 찾기 위해 사용합니다. 다음 명령을 사용하여 / etc / environment 파일 에서 이러한 변수를 설정할 수 있습니다 .&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo gedit /etc/environment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;JAVA_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/usr/lib/jvm/java-8-openjdk-amd64&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;JRE_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/usr/lib/jvm/java-8-openjdk-amd64/jre&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;모든 작업이 완료되었으며 Linux 시스템에 Java 8이 성공적으로 설치됐다.&lt;/p&gt;

&lt;p&gt;[출처]&lt;a href=&quot;https://tecadmin.net/install-oracle-java-8-ubuntu-via-ppa/&quot;&gt;tecadmin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-이클립스eclipse-ide-설치하기oxygen&quot;&gt;2. 이클립스(Eclipse IDE) 설치하기(Oxygen)&lt;/h2&gt;

&lt;p&gt;CPP IDE를 찾던 중 다양한 이야기가 있는데, 어떤 포럼에선 IDE를 받지 말고, vim + gcc 뭐 이런 조합으로 가라는 등의 이야기가 있었다. 하지만, 기존에 IDE를 쓰면서 워낙 장점이 많았던 것을 경험한 터라, 쉽게 커맨드 라인 기반의 시스템으로 가기 쉽지 않았다. 특히 vim은 사용하려면 에디팅 방법을 익혀야 하는 상당한 스트레스가 있다. 
그래서 가장 익숙한 이클립스를 활용하여, 개발을 해보기로 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.eclipse.org/downloads/packages/release/oxygen/3a&quot;&gt;이클립스 IDE 받으러 가기&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;각자 시스템에 맞춰 다운로드를 합니다. 단, “Eclipse IDE for C/C++ Developers” 를 다운로드 하는 것을 잊지 말자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/cpp/eclipse01.png&quot; title=&quot;이클립스 CPP 개발자 IDE 다운로드&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/cpp/eclipse02.png&quot; title=&quot;이클립스 Oxygen 버전 받기&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-단계--압축풀기&quot;&gt;1 단계 – 압축풀기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ tar xvzf ./eclipse-cpp-oxygen-3a-linux-gtk-x86_64.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-단계--eclipse-폴더를-opt-폴더로-이동&quot;&gt;2 단계 – Eclipse 폴더를 /opt 폴더로 이동&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo mv eclipse /opt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-단계--터미널-실행-설정&quot;&gt;3 단계 – 터미널 실행 설정&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo gedit /usr/bin/eclipse
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#! /bin/sh&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ECLIPSE_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/opt/eclipse
&lt;span class=&quot;nv&quot;&gt;$ECLIPSE_HOME&lt;/span&gt;/eclipse &lt;span class=&quot;nv&quot;&gt;$*&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;중간중간 warning이 떠서 찝찝하지만, 진행했다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ source /etc/environment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo chmod 755 /usr/bin/eclipse
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;4-단계--x윈도우-바로가기-설정&quot;&gt;4 단계 – X윈도우 바로가기 설정&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo gedit /usr/share/applications/eclipse.desktop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Desktop Entry]

&lt;span class=&quot;nv&quot;&gt;Encoding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;UTF-8
&lt;span class=&quot;nv&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Eclipse
&lt;span class=&quot;nv&quot;&gt;Comment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Eclipse IDE
&lt;span class=&quot;nv&quot;&gt;Exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;eclipse
&lt;span class=&quot;nv&quot;&gt;Icon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/opt/eclipse/icon.xpm
&lt;span class=&quot;nv&quot;&gt;Terminal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Application
&lt;span class=&quot;nv&quot;&gt;Categories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Development
&lt;span class=&quot;nv&quot;&gt;StartupNotif&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/cpp/eclipse03.png&quot; title=&quot;바로가기 설정&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5-단계---eclipse-cdt-설치&quot;&gt;5 단계 - Eclipse CDT 설치&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ eclipse
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/cpp/eclipse04.png&quot; title=&quot;바로가기 설정&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/cpp/eclipse05.png&quot; title=&quot;바로가기 설정&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;난 CDT를 설치하여 위에 작업 아이콘이 보인다. 하지만, 처음에 Eclipse를 설치하면 없기 때문에 설치를 해야한다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Kiho Lee</name></author><category term="C++" /><category term="introduction" /><category term="이클립스" /><category term="Eclipse" /><summary type="html"></summary></entry><entry><title type="html">01.CPP 학습에 앞서 CPP란 어떤 프로그램 언어일까?</title><link href="http://localhost:4000/categories/c++/CPP-01-introduction.html" rel="alternate" type="text/html" title="01.CPP 학습에 앞서 CPP란 어떤 프로그램 언어일까?" /><published>2019-12-08T19:17:13+00:00</published><updated>2019-12-08T19:17:13+00:00</updated><id>http://localhost:4000/categories/c++/CPP-01-introduction</id><content type="html" xml:base="http://localhost:4000/categories/c++/CPP-01-introduction.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;cpp란-어떤-프로그램-언어일까&quot;&gt;CPP란 어떤 프로그램 언어일까?&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/cpp/c++_logo.png&quot; width=&quot;40%&quot; height=&quot;30%&quot; title=&quot;C++ 아이콘&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-개요&quot;&gt;1. 개요&lt;/h2&gt;

&lt;p&gt;C언어를 부분집합으로 갖고[1] 객체 지향 및 일반화 프로그래밍과 같은 멀티 패러다임을 지원하는 프로그래밍 언어이다. 1979년에 C언어에서 직접적으로 파생된 C with Classes라는 이름의 언어로 시작되었다가, 1983년에 지금의 이름을 갖게 되었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-특징&quot;&gt;2. 특징&lt;/h2&gt;

&lt;p&gt;비아르네 스트로우스트루프(Bjarne Stroustrup)[2]가 C언어를 바탕으로 만들었다. 참고로 C 계열 언어에서 “++”라는 것은 1을 더해서 원래 변수에 대입하라는 뜻이다.[3] C는 B 언어를 계승한다는 의미에서 C가 되었는데 왜 C++은 D가 아니라 C++가 되었냐하면 C 언어를 거의 그대로 두고 필요한 만큼만 향상시켰기 때문이다. 그래서 C에서 되는 게 C++에서도 된다. 비슷한 이름인 C#과의 차이도 이러한 점에서 나타난다.&lt;/p&gt;

&lt;p&gt;C++ 커뮤니티는 C++가 단순히 객체지향 프로그래밍 언어라고 분류되는 것을 오류라고 여긴다.[4] C++에서는 객체지향 프로그래밍 패러다임과 동등한 강도로 일반화 프로그래밍 패러다임을 강조하고 있다.[5] 쉽게 말하자면 C++는 기존의 C 문법이 대표하는 절차적 프로그래밍, 클래스가 대표하는 객체지향 프로그래밍, 템플릿이 대표하는 일반화 프로그래밍의 세 기둥으로 지지되고 있는 언어이다.&lt;/p&gt;

&lt;p&gt;유사한 의견으로 Effective C++의 저자 스콧 마이어스는 C++가 4가지 하위언어의 연합체라고 언급한다. C, 객체지향 C++, 템플릿 C++, STL.[6] 각각의 ‘하위 언어’ 들의 규칙과 구현이 전부 다르므로 복잡도가 상당히 높으며 ‘C with classes’라는 초기 명칭과는 한참 차이가 날 정도로 확장되었다.&lt;/p&gt;

&lt;p&gt;쓸 때는 C++라고 쓰지만 읽을 때는 시 플러스 플러스, 혹은 줄여서 시플플이라고 읽는다. 한국에서는 사실상 속어에 가까운 씨쁠쁠로 불린다.(…)[7] 연세가 꽤 있으신 교수님 중에는 간혹 ‘시 더블 플러스’라고 읽는 경우도 있다. 미국에서는 그냥 CPP(시피피)라고 읽는다.&lt;/p&gt;

&lt;p&gt;한국에서 컴퓨터공학과를 다닐 경우 배울 수 있는 프로그래밍 언어 3개 중에 속한다. 나머지 둘은 C와 Java. 그러나 실상 C++11 이후의 모던 C++ 기능을 가르쳐주는 곳이 매우 드물어서 C++의 객체 지향만 조금 배울 수 있다.[8] 제대로 다루기 위해서는 별도의 서적을 참고하는 것이 권장되며, 실제 프로젝트의 코드에 대해 탐구하고 경험해보는 것이 좋다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-c와-차이점&quot;&gt;3. C와 차이점&lt;/h2&gt;

&lt;p&gt;C++의 개발이 C언어를 기반으로 이루어졌기 때문에 대부분의 C 프로그램은 C++ 컴파일러에서도 문제없이 컴파일된다.[9] 초기 C++ 컴파일러는 일단 C++ 코드를 C로 변환하고 그걸 C로 컴파일하는 방식을 사용했을 정도. 하지만 객체지향 프로그래밍이나 일반화 프로그래밍이란 것은 단순한 문법이 아니라 코딩의 패러다임을 말한다. 그래서 C++ 방식으로 코딩하려면 해당 코드에서 C++에 새로 도입된 것을 추가하는 게 아니라 설계부터 시작해서 완전히 새로 해야 하는 경우가 많으므로, 초심자 입장에서는 서로 다른 별개의 언어로 보고 접근하는 것이 안전하다. 그래서 C로 프로그래밍에 발을 들어 놓은 후 C++/Java로 업그레이드(…) 테크를 타는 학생에게 C++ 프로그래밍을 해 오라 하면, C에서는 구조체라는 개념이 있더라도 잘해봐야 C++의 입출력 객체를 이용하는 정도를 넘지 못하고 절차적 프로그래밍을 그대로 따라가는 영락없는 C 스타일의 프로그램이 튀어나오기 일쑤다.&lt;/p&gt;

&lt;p&gt;그 이유는 C++의 객체지향이 다른 객체지향 언어에 비해 이해하기가 그렇게 만만한 개념이 아닌 데다가 C++의 객체지향은 C를 유지하면서 그대로 얹어놔서 신경 써야 할 부분이 많다. 다른 객체지향 언어에서보다 잘 다루는데 더 많은 공부가 필요하다. 사실 C++의 객체지향이 다른 언어와 비교하였을 때 개념적인 면에서는 아주 심각한 차이가 있는 것은 아니나, 실제로는 다른 언어에서는 무조건 new를 통해 힙에 생성해야 하는 객체를 스택에도 생성하고, 함수 인자 전달 시 이것저것 규칙이 많아 복잡해 보인다. 큰 맥락을 꿰뚫으면 직관적으로 이해되는 부분이지만, 그렇게 되는데 시간이 오래 걸린다.&lt;/p&gt;

&lt;p&gt;C++ → C 테크도 만만치가 않다. C → C++은 절차지향 언어의 사고방식, C++ → C는 객체지향 언어의 사고방식이 머릿속에 굳어버리기 때문이다. C++가 C의 모든 기능을 포괄하고 있으므로 C++을 할 줄 알면 C도 할 줄 안다고 생각하기 쉽지만, 사실 C++가 명시적으로 비교적 간단히 사용할 수 있도록 제공하는 기능들을 C에서는 암묵적으로 여러 가지 수많은 ‘트릭’을 통해서 쥐어짜내듯이 만들어 사용하는 경우가 많다.[10][11] 게다가, 저런 트릭은 언어 차원에서 정식으로 제공한다기보다 말 그대로 ‘트릭’에 가까우므로 이상한 조건들이 붙는 경우가 종종 있고, 그것들을 정확히 파악하고 있지 않으면 상당히 찾아내기 어려운 에러를 내는 경우도 많다. 말 그대로 C와 C++은 완전히 다른 언어로 파악하고 접근하는 것이 좋다. “잘 짜인 C 프로그램은 C++ 컴파일러로 컴파일할 수 있어야 한다”는 말도 1999년에 C99 표준이 나오면서 틀린 말이 되어버리기도 했고…&lt;/p&gt;

&lt;p&gt;그래서 많은 대학에서 컴공 1학년 1학기 때 C를 먼저 가르치고 빠르면 2학기, 늦어도 2학년에 C++를 가르치지만, 교수가 절차지향이 머리에 굳어버린다며 컴공에서 C 대신 C++와 객체를 먼저 가르치고 C는 아예 건드리지도 않고 다른 하드웨어 관련 학과에서만 가르치는 대학들도 많다. 객체지향만 배운다면 Java부터 시작하는 게 낫지만, 포인터 등을 통해 메모리와 각종 저수준(low level) 프로그래밍과 객체지향을 함께 배울 수 있기 때문이다. 컴공의 경우에는 C++를 모르면 2학년부터는 강의를 전혀 이해할 수 없기 때문에 의외로 많은 학생들이 중도포기를 하게 되며 컴공을 나왔는데도 프로그래밍을 전혀 못하는 학생들이 수두룩하게 발생하고 있다.&lt;/p&gt;

&lt;p&gt;C를 알고 있다고 C++을 쉽게 할 수 있는 것은 아니다. 두 언어는 추구하는 설계 구조가 상당히 다르기 때문이다. C언어는 절차 지향이지만 C++은 절차 지향, 객체 지향, 일반화 프로그래밍, 함수형 프로그래밍을 모두 지원하는 언어다. 그래서 C언어를 알고 있는 사람이 C++ 초보자용 교재를 1권 끝내고 프로그램을 만들어 보라고 해도 대부분 C 방식에서 벗어나지 못한다. C++ 방식을 잘 활용하려면 STL까지 배운 다음 자료구조와 스트림, 템플릿 정도는 쓸 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;한편, C, C++ 중 어디가 쉽다라던가(…) 하는 건 어디까지나 간단한 프로그램의 예일 뿐이다. 둘의 설계 구조가 다르고 성능상 미묘한 차이밖에 안 난다. C의 함수구조에서는 다중의 인자값 전달이 필수적인데 구조체에 전부 때려박더라도 전역변수가 아닌 이상 적어도 1개는 전달해야 한다. 반면에 C++ 측은 클래스의 this를 활용하면 인자 전달없이 클래스에 속한 멤버함수 호출만 할 수 있다. 헤더참조 구조가 중복정의로 복잡해지는건 덤. Node.js 모듈구조를 참고 해보면 module.exports로만 다른모듈과 상호작용 할 수 있는데 C 계열은 헤더를 넣으면 그 안에 있는 모든 건 상호작용되고 원치 않으면 소스파일과 분리해야한다. 다만, C++의 경우 C++20 개정판부터 모듈 개념이 도입될 예정이므로[12] 이러한 단점은 점차 시간이 지남에 따라 극복될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-c에서의-객체지향-프로그래밍&quot;&gt;4. C++에서의 객체지향 프로그래밍&lt;/h2&gt;

&lt;p&gt;C++은 객체 지향 프로그래밍을 지원하지만, C++의 객체지향은 다른 객체지향 언어에서와는 성격이 좀 다르다. 대부분의 객체지향 언어에서는 많은 부분을 런타임에 처리하며 메모리를 자동으로 관리하는 반면, C++에서는 최대한 많은 것을 컴파일 타임에 처리하는 것을 지향하며 메모리 등을 프로그래머가 직접 관리하게 하기 때문에 전반적인 클래스 디자인 자체가 상당한 차이를 보이게 된다. Java 등의 다른 객체지향 언어에서와 같은 방식으로 C++ 클래스를 디자인하면 거의 틀림없이 컴파일이 제대로 안 되거나 메모리 문제가 발생한다. 특히 쓰레기 수집을 지원하는 Java에서 C++ 테크를 탄 학생이라면 처음에는 메모리가 줄줄 새는 프로그램을 만들게 될 것이다. 반면 C++ 스타일로 다른 객체지향 언어에서 프로그래밍을 하는 경우 특별히 안 될 것은 없지만[13], 해당 언어의 스타일로 작성한 코드에 비해 시간이 많이 걸리고 너저분해 보이며 클래스 구조가 경직되어 수정하기 어려워진다.&lt;/p&gt;

&lt;p&gt;대표적인 예가 함수 내부에서 객체를 동적으로 생성해서 그 포인터를 반환하는 것. C++에서는 이는 메모리 문제를 일으키기 딱 맞는 방식이라서 클래스 디자인 단계에서 이런 종류의 함수가 필요없게 하기 위한 고려가 필요하지만[14], 가비지 컬렉션이 자동으로 되는 언어에서는 매우 흔히 사용되는 방법이다. 이런 차이 때문에, Java, C# 등의 언어를 먼저 접한 프로그래머들은 C++의 객체지향이 짝퉁이라며 싫어하기도 한다. 하지만 객체지향 프로그래밍 언어임을 전면에 내세우는 Java나 C#과 달리, 객체지향 패러다임도 지원하는 멀티패러다임 언어 C++ 입장에서는 얼마나 순수하게 객체지향의 이상을 잘 따르는가보다 C++가 제공하는 다른 패러다임까지 아우르는 내적 일관성이 더 중요하므로 해당 언어들과 C++를 동일선상에 놓고 비교할 수는 없다.&lt;/p&gt;

&lt;p&gt;이러한 차이가 생기는 것은 대부분의 객체지향 언어는 직접적으로 Smalltalk의 영향을 받은 반면, C++는 Smalltalk보다 먼저 객체지향의 초보적인 개념을 제시한 시뮬레이션 전용 언어인 Simula에서 직접 영향을 받았기 때문이다. 이는 C 프로그램과의 호환성을 고려한 결과이기도 하지만, 기본적으로 C++에서 프로그램의 성능을 희생시키지 않기 위해서였다. Smalltalk의 경우 당시의 기술적 한계도 있고 해서 C보다 대체로 수십 배 정도 느렸고, 이는 C++에서 지향하는 결과가 아니었기 때문이다.&lt;/p&gt;

&lt;p&gt;다만 이런 제한이 생기는 건 오래된 스타일의 C++ 코드에서나 그런 것이고, Modern C++에서는 스마트 포인터[15]를 사용하거나 이를 move[16]하는 방식으로 그들과 완전히 같은 문법이 구현 가능하기 때문에 더 이상 해당이 없는 사항이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-c에서의-일반화-프로그래밍&quot;&gt;5. C++에서의 일반화 프로그래밍&lt;/h2&gt;

&lt;p&gt;C++에서는 템플릿을 이용한 일반화 프로그래밍(Generic Programming)이 매우 폭넓게 사용된다. 특히 C++11을 시작으로 하는 모던 C++는 일반화 프로그래밍을 빼고 이야기하는 것이 불가능하다. 당장 매우 널리 사용되는 std::string만해도 실제로 들여다보면 std::basic_string&lt;char&gt;와 같은 형태의 템플릿 클래스의 특수화에 지나지 않는다. 또, C와는 달리 포인터 배열 대신에 std::vector를 기본으로 사용하라고 가르치는데[17], 이 std::vector 또한 저장될 변수의 타입을 파라미터로 받아들이는 템플릿 클래스이다. (예를 들어 std::vector&lt;int&gt;)&lt;/int&gt;&lt;/char&gt;&lt;/p&gt;

&lt;p&gt;일반화 프로그래밍의 결과물으로는 C++ 표준 라이브러리의 일부분으로 포함된 컨테이너, STL 같은 것들이 있으므로, C++ 표준 라이브러리를 사용하는 순간 일반화 프로그래밍의 도움을 받는 것이다. 따라서 ‘나는 C++를 사용하지만 템플릿을 이용한 일반화 프로그래밍은 어려우니까 패스하겠다’는 말은 애초에 성립하지 않는다.&lt;/p&gt;

&lt;p&gt;중급 이하 개발자는 이런 결과물을 일상적으로 쉽게 가져다 쓰면 되고, 직접 만들어 쓸 필요는 없다. 이는 중급 개발자 정도로는 템플릿을 사용한 일반화 프로그래밍 기법을 정확하게 적용하는 것이 무척 까다롭고, 디버깅할 때 이해 불가능한 컴파일러 메세지를 받게 되는 경우가 많아서 발견된 오류를 수정하기도 어렵기 때문이다.&lt;/p&gt;

&lt;p&gt;이런 이유로 C++ 학습 초반에 템플릿 프로그래밍을 직접 하는 것을 피하고 기껏해야 컨테이너 클래스만 사용하는 습관이 들다보니, C++는 객체지향 언어이고 STL이라는 템플릿 라이브러리를 덤으로 쓸 수 있는 정도라는 오해가 널리 퍼진 것이라 생각된다. 하지만, 특수 목적의 컨테이너를 설계하거나 범용 라이브러리를 설계하는 수준의 고급 개발자가 되려면 템플릿을 사용한 일반화 프로그래밍을 해야 한다.&lt;/p&gt;

&lt;p&gt;Java나 C#에서 찾아볼 수 있는 Generics가 지금 설명한 C++ 일반화 프로그래밍의 아주 제한된 형태의 적용례에 해당한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;6-템플릿-메타-프로그래밍&quot;&gt;6. 템플릿 메타 프로그래밍&lt;/h2&gt;

&lt;p&gt;TMP, Template Meta Programming&lt;/p&gt;

&lt;p&gt;템플릿 문법을 응용해서 컴파일 시점에 자동 코드 생성 및 계산 같은 것을 한다는 개념이다. 영문위키백과 배우기 어렵고 알아보기도 힘들고, 오류 찾기도 힘들다. 당연히 C++의 템플릿을 모를 경우에는 아예 이해할 수가 없는 개념이기도 하다. 하지만 알아두면 은근 써먹을 데가 많다.&lt;/p&gt;

&lt;p&gt;까딱 잘못하면 바이너리 크기가 n배로 증가하는 참사가 발생할 수도 있다. 이럴 경우 명령어 캐시의 실패 확률이 늘어나서 오히려 성능이 하락할 수도 있다. 하지만 제대로 구현하면 바이너리 크기에서 손해를 보지 않으면서도 컴파일 시점에 다양한 처리나 계산을 할 수 있기에 라이브러리 구현에 종종 이용된다.&lt;/p&gt;

&lt;p&gt;그리고 처음에는 너무 병맛이라 입에서 욕이 튀어나올 수 있다. 악용에 가까운 테크닉으로는 다음이 있다.
SFINAE(Substitution Failure Is Not An Error): 함수를 오버로딩 하는데 있어 조건에 따라 일부러 문법적으로 틀린 템플릿의 구현 코드를 발생시켜 틀리지 않은 문법이 되는 특정 오버로드만 선택되게 만드는 테크닉이다. C++ 문법의 틈새에 존재하는 문법 오류이지만 컴파일 에러가 아닌 상황을 적극 활용하는 것이다. 직역하면 ‘대입 실패가 에러라는 뜻은 아니다’라는 뜻이다.
Expression Templates: 디자인 패턴의 일종인 Proxy pattern 기반의 Lazy evaluation이 적용되는 효율적인 계산 코드를 컴파일 시점에 자동으로 생성하는 테크닉. 일반적으로 연산 도중의 임시 객체 생성 문제를 이 기법을 통해 해결하는 경우가 있다. RVO(Return Value Optimization)를 감안하더라도 C++ 특성상 연산자를 활용하는 과정에서, 직접적인 연산을 시도하면 임시 객체의 생성을 완전히 막을 수는 없기 때문이다.&lt;/p&gt;

&lt;p&gt;이 개념은 C++ 템플릿이 코드를 컴파일 시점에 확장하는 방식이라는 것과 비타입 인수도 줄 수 있다는 것을 이용한다는 점을 이용악용하는 것으로 다른 언어에서는 비슷한 것도 찾기 힘들다. 전술한대로 Java나 C#에 있는 제네릭은 TMP가 아닌 일반화 프로그래밍(Generic Programming)의 개념이다.&lt;/p&gt;

&lt;p&gt;같은 템플릿 문법을 사용하지만 앞 문단에서 강조한 일반화 프로그래밍과는 엄연히 목표가 다르다. 일반화 프로그래밍이 코드의 범용성 증대를 목표로 한다면 템플릿 메타 프로그래밍은 컴파일러를 고문해 어떻게든 실행시간의 이득을 얻은 것을 목표로 한다. 근본적으로 C++의 템플릿 문법이 compile-time turing complete하기 때문에 이런 일이 가능한 것이다. C++ 안에 컴파일 타임 전용의 또 다른 언어가 숨어있는 것과 같은 상황이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;기존의 C에 대해서 얇팍하게 알았던 지식은 C++을 학습할 때 크게 도움이 되지 않을 것 같다. 오히려 C언어를 자세히 알지 못하는게 C++을 학습하는 데 더 도움이 될 수 있지 않을까 생각도 한다. ROS 및 로봇을 개발 하기 위해서는 C/C++언어에 상당히 익숙해 질 필요가 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;[출처]&lt;a href=&quot;https://namu.wiki/w/C%2B%2B&quot;&gt;나무위키&lt;/a&gt;&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="C++" /><category term="introduction" /><summary type="html"></summary></entry><entry><title type="html">05.GIT 저장소 수정하기와 저장하기</title><link href="http://localhost:4000/categories/git/GIT-05-modifying-and-saving-repository.html" rel="alternate" type="text/html" title="05.GIT 저장소 수정하기와 저장하기" /><published>2019-12-08T10:50:13+00:00</published><updated>2019-12-08T10:50:13+00:00</updated><id>http://localhost:4000/categories/git/GIT-05-modifying-and-saving-repository</id><content type="html" xml:base="http://localhost:4000/categories/git/GIT-05-modifying-and-saving-repository.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;git의-기초---수정하고-저장소에-저장하기&quot;&gt;Git의 기초 - 수정하고 저장소에 저장하기&lt;/h1&gt;

&lt;p&gt;실제 존재하는 Git 저장소를 하나 만들었고 워킹 디렉토리에 Checkout도 했다. 이제는 파일을 수정하고 파일의 스냅샷을 커밋해 보자. 파일을 수정하다가 저장하고 싶으면 스냅샷을 커밋한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Checkout은 처음 Git을 접하면 생소할 수 있다. Git은 스냅샷을 기반으로 데이터의 내용을 저장하고 추적한다. Checkout이 되어있는 디렉토리란(워킹디렉토리)는 현재 .git 폴더에서 관리하는 워킹 트리에 데이터가 업데이트 되어 워킹트리, 워킹트리의 선택 브랜치, 워킹 디렉토리 모두 최신화 되어 있는 상태를 말한다. (이렇게 설명하면 처음 접하는 사람은 더 헷갈릴 수 있을 것 같네…)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;이제부터 설명하는 내용이 Git에 매우 중요한 내용이지만, 이해하기 쉽지 않을 수 있다. 차근차근 보도록 해보자.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;워킹 디렉토리의 모든 파일은 크게 Tracked(관리대상임)와 Untracked(관리대상이 아님)로 나눈다. Tracked 파일은 이미 스냅샷에 포함돼 있던 파일이다. Tracked 파일은 또 Unmodified(수정하지 않음)와 Modified(수정함) 그리고 Staged(커밋으로 저장소에 기록할) 상태 중 하나이다. 간단히 말하자면 Git이 알고 있는 파일이라는 것이다.&lt;/p&gt;

&lt;p&gt;그리고 나머지 파일은 모두 Untracked 파일이다. Untracked 파일은 워킹 디렉토리에 있는 파일 중 스냅샷에도 Staging Area에도 포함되지 않은 파일이다. 처음 저장소를 Clone 하면 모든 파일은 Tracked이면서 Unmodified 상태이다. 파일을 Checkout 하고 나서 아무것도 수정하지 않았기 때문에 그렇다.&lt;/p&gt;

&lt;p&gt;마지막 커밋 이후 아직 아무것도 수정하지 않은 상태에서 어떤 파일을 수정하면 Git은 그 파일을 Modified 상태로 인식한다. 실제로 커밋을 하기 위해서는 이 수정한 파일을 Staged 상태로 만들고, Staged 상태의 파일을 커밋한다. 이런 라이프사이클을 계속 반복한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/git/git-lifecycle.png&quot; title=&quot;Git 파일의 라이프 사이클&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-파일의-상태-확인하기&quot;&gt;1. 파일의 상태 확인하기&lt;/h2&gt;

&lt;p&gt;파일의 상태를 확인하려면 보통 &lt;strong&gt;git status&lt;/strong&gt; 명령을 사용한다. Clone 한 후에 바로 이 명령을 실행하면 아래과 같은 메시지를 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 내용은 파일을 하나도 수정하지 않았다는 것을 말해준다. Tracked 파일은 하나도 수정되지 않았다는 의미다. Untracked 파일은 아직 없어서 목록에 나타나지 않는다. 그리고 현재 작업 중인 브랜치를 알려주며 서버의 같은 브랜치로부터 진행된 작업이 없는 것을 나타낸다. 기본 브랜치가 master이기 때문에 현재 브랜치 이름이 “master” 로 나온다. 브랜치 관련 내용은 차차 알아가자. Git 브랜치 에서 브랜치와 Refs에 대해 자세히 다룬다.&lt;/p&gt;

&lt;p&gt;프로젝트에 &lt;strong&gt;README&lt;/strong&gt; 파일을 만들어보자. &lt;strong&gt;README&lt;/strong&gt; 파일은 새로 만든 파일이기 때문에 &lt;strong&gt;git status&lt;/strong&gt; 를 실행하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Untracked files&lt;/code&gt;에 들어 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo 'My Project' &amp;gt; README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)

    README

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;README&lt;/strong&gt; 파일은 “Untracked files” 부분에 속해 있는데 이것은 &lt;strong&gt;README&lt;/strong&gt; 파일이 Untracked 상태라는 것을 말한다. Git은 Untracked 파일을 아직 스냅샷(커밋)에 넣어지지 않은 파일이라고 본다. 파일이 Tracked 상태가 되기 전까지는 Git은 절대 그 파일을 커밋하지 않는다. 그래서 일하면서 생성하는 바이너리 파일 같은 것을 커밋하는 실수는 하지 않게 된다. &lt;strong&gt;README&lt;/strong&gt; 파일을 추가해서 직접 Tracked 상태로 만들어 보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-파일을-새로-추적하기&quot;&gt;2. 파일을 새로 추적하기&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;git add&lt;/strong&gt; 명령으로 파일을 새로 추적할 수 있다. 아래 명령을 실행하면 Git은 README 파일을 추적한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;git status&lt;/strong&gt; 명령을 다시 실행하면 README 파일이 Tracked 상태이면서 커밋에 추가될 Staged 상태라는 것을 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    new file:   README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;“Changes to be committed” 에 들어 있는 파일은 Staged 상태라는 것을 의미한다. 커밋하면 git add 를 실행한 시점의 파일이 커밋되어 저장소 히스토리에 남는다. 앞에서 git init 명령을 실행한 후, git add (files) 명령을 실행했던 걸 기억할 것이다. 이 명령을 통해 디렉토리에 있는 파일을 추적하고 관리하도록 한다. git add 명령은 파일 또는 디렉토리의 경로를 아규먼트로 받는다. 디렉토리면 아래에 있는 모든 파일들까지 재귀적으로 추가한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-modified-상태의-파일을-stage-하기&quot;&gt;3. Modified 상태의 파일을 Stage 하기&lt;/h2&gt;

&lt;p&gt;이미 Tracked 상태인 파일을 수정하는 법을 알아보자. &lt;strong&gt;CONTRIBUTING.md&lt;/strong&gt; 라는 파일을 수정하고 나서 &lt;strong&gt;git status&lt;/strong&gt; 명령을 다시 실행하면 결과는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    new file:   README

Changes not staged for commit:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 &lt;strong&gt;CONTRIBUTING.md&lt;/strong&gt; 파일은 “Changes not staged for commit” 에 있다. 이것은 수정한 파일이 Tracked 상태이지만 아직 Staged 상태는 아니라는 것이다. Staged 상태로 만들려면 &lt;strong&gt;git add&lt;/strong&gt; 명령을 실행해야 한다. &lt;strong&gt;git add&lt;/strong&gt; 명령은 파일을 새로 추적할 때도 사용하고 수정한 파일을 Staged 상태로 만들 때도 사용한다. Merge 할 때 충돌난 상태의 파일을 Resolve 상태로 만들때도 사용한다. add의 의미는 프로젝트에 파일을 추가한다기 보다는 다음 커밋에 추가한다고 받아들이는게 좋다. &lt;strong&gt;git add&lt;/strong&gt; 명령을 실행하여 &lt;strong&gt;CONTRIBUTING.md&lt;/strong&gt; 파일을 Staged 상태로 만들고 &lt;strong&gt;git status&lt;/strong&gt; 명령으로 결과를 확인해보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;두 파일 모두 Staged 상태이므로 다음 커밋에 포함된다. 하지만 아직 더 수정해야 한다는 것을 알게 되어 바로 커밋하지 못하는 상황이 되었다고 생각해보자. 이 상황에서 CONTRIBUTING.md 파일을 열고 수정한다. 이제 커밋할 준비가 다 됐다고 생각할 테지만, Git은 그렇지 않다. git status 명령으로 파일의 상태를 다시 확인해보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;사실 이 부분이 어떻게 보면 복잡하게 staged 상태를 구분하는 이유가 생기는 큰 원인일 수 있다. 직접 만들어서 비교해보면 그 차이를 쉽게 이해할 수 있을 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;[참고]본래 출처에서 사용한 에디터 도구는 vim이라는 툴이고 매우 유명한 툴이지만, 사용법이 다소 복잡하여 처음 리눅스 환경을 적응해야하는 사람들에게는 다소 어려울 수 있다. 따라서, gedit나 nano와 같은 툴을 사용하는 게 훨씬 수월 할 수 있다. gedit는 윈도우 환경에서 notepad(매모장)과 같은 에디터라고 볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;헉! &lt;strong&gt;CONTRIBUTING.md&lt;/strong&gt; 가 Staged 상태이면서 동시에 Unstaged 상태로 나온다. 어떻게 이런 일이 가능할까? &lt;strong&gt;git add&lt;/strong&gt; 명령을 실행하면 Git은 파일을 바로 Staged 상태로 만든다. 지금 이 시점에서 커밋을 하면 &lt;strong&gt;git commit&lt;/strong&gt; 명령을 실행하는 시점의 버전이 커밋되는 것이 아니라 마지막으로 &lt;strong&gt;git add&lt;/strong&gt; 명령을 실행했을 때의 버전이 커밋된다. 그러니까 &lt;strong&gt;git add&lt;/strong&gt; 명령을 실행한 후에 또 파일을 수정하면 &lt;strong&gt;git add&lt;/strong&gt; 명령을 다시 실행해서 최신 버전을 Staged 상태로 만들어야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-파일-상태를-짤막하게-확인하기&quot;&gt;4. 파일 상태를 짤막하게 확인하기&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;git status&lt;/strong&gt; 명령으로 확인할 수 있는 내용이 좀 많아 보일 수 있다. 사실 그렇다. 좀 더 간단하게 변경 내용을 보여주는 옵션이 있다. &lt;strong&gt;git status -s&lt;/strong&gt; 또는 &lt;strong&gt;git status –short&lt;/strong&gt; 처럼 옵션을 주면 현재 변경한 상태를 짤막하게 보여준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status -s
M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;아직 추적하지 않는 새 파일 앞에는 ?? 표시가 붙는다. Staged 상태로 추가한 파일 중 새로 생성한 파일 앞에는 &lt;strong&gt;A&lt;/strong&gt; 표시가, 수정한 파일 앞에는 &lt;strong&gt;M&lt;/strong&gt; 표시가 붙는다. 위 명령의 결과에서 상태정보 컬럼에는 두 가지 정보를 보여준다. 왼쪽에는 Staging Area에서의 상태를, 오른쪽에는 Working Tree에서의 상태를 표시한다. &lt;strong&gt;README&lt;/strong&gt; 파일 같은 경우 내용을 변경했지만 아직 Staged 상태로 추가하지는 않았다. &lt;strong&gt;lib/simplegit.rb&lt;/strong&gt; 파일은 내용을 변경하고 Staged 상태로 추가까지 한 상태이다. 위 결과에서 차이점을 비교해보자. &lt;strong&gt;Rakefile&lt;/strong&gt; 은 변경하고 Staged 상태로 추가한 후 또 내용을 변경해서 Staged 이면서 Unstaged 상태인 파일이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;위의 설명을 들으면서 내용을 이해하면 사실 더 이해가 안될 수도 있다. &lt;strong&gt;Rakefile&lt;/strong&gt;만 하더라도 Staged상태이면서 Unstaged상태라는 놀라운 설명이… 다시말해, &lt;strong&gt;Rakefile&lt;/strong&gt;을 수정하고, &lt;strong&gt;add Rakefile&lt;/strong&gt;이 된 후, 또, &lt;strong&gt;Rakefile&lt;/strong&gt;을 수정했다는 얘기다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-파일-무시하기&quot;&gt;5. 파일 무시하기&lt;/h2&gt;

&lt;p&gt;어떤 파일은 Git이 관리할 필요가 없다. 보통 로그 파일이나 빌드 시스템이 자동으로 생성한 파일이 그렇다. 그런 파일을 무시하려면 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 만들고 그 안에 무시할 파일 패턴을 적는다. 아래는 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일의 예이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat .gitignore
*.[oa]
*~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;첫번째 라인은 확장자가 “.o” 나 “.a” 인 파일을 Git이 무시하라는 것이고 둘째 라인은 &lt;strong&gt;~&lt;/strong&gt; 로 끝나는 모든 파일을 무시하라는 것이다. 보통 대부분의 텍스트 편집기에서 임시파일로 사용하는 파일 이름이기 때문이다. “.o” 와 “.a” 는 각각 빌드 시스템이 만들어내는 오브젝트와 아카이브 파일이고 &lt;strong&gt;~&lt;/strong&gt; 로 끝나는 파일은 Emacs나 VI 같은 텍스트 편집기가 임시로 만들어내는 파일이다. 또 log, tmp, pid 같은 디렉토리나, 자동으로 생성하는 문서 같은 것들도 추가할 수 있다. &lt;strong&gt;.gitignore&lt;/strong&gt; 파일은 보통 처음에 만들어 두는 것이 편리하다. 그래서 Git 저장소에 커밋하고 싶지 않은 파일을 실수로 커밋하는 일을 방지할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.gitignore 파일에 입력하는 패턴은 아래 규칙을 따른다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;아무것도 없는 라인이나, &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;로 시작하는 라인은 무시한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;표준 Glob 패턴을 사용한다. 이는 프로젝트 전체에 적용된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;슬래시(/)로 시작하면 하위 디렉토리에 적용되지(Recursivity) 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;디렉토리는 슬래시(/)를 끝에 사용하는 것으로 표현한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;느낌표(!)로 시작하는 패턴의 파일은 무시하지 않는다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Glob 패턴은 &lt;strong&gt;정규표현식&lt;/strong&gt;을 단순하게 만든 것으로 생각하면 되고 보통 쉘에서 많이 사용한다. 애스터리스크(&lt;strong&gt;*&lt;/strong&gt;)는 문자가 하나도 없거나 하나 이상을 의미하고, &lt;strong&gt;[abc]&lt;/strong&gt; 는 중괄호 안에 있는 문자 중 하나를 의미한다(그러니까 이 경우에는 a, b, c). 물음표(?)는 문자 하나를 말하고, &lt;strong&gt;[0-9]&lt;/strong&gt; 처럼 중괄호 안의 캐릭터 사이에 하이픈(-)을 사용하면 그 캐릭터 사이에 있는 문자 하나를 말한다. 애스터리스크 2개를 사용하여 디렉토리 안의 디렉토리 까지 지정할 수 있다. &lt;strong&gt;a/**/z&lt;/strong&gt; 패턴은 &lt;strong&gt;a/z, a/b/z, a/b/c/z&lt;/strong&gt; 디렉토리에 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;아래는 &lt;strong&gt;.gitignore&lt;/strong&gt;파일의 예이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 확장자가 .a인 파일 무시
*.a

# 윗 라인에서 확장자가 .a인 파일은 무시하게 했지만 lib.a는 무시하지 않음
!lib.a

# 현재 디렉토리에 있는 TODO파일은 무시하고 subdir/TODO처럼 하위디렉토리에 있는 파일은 무시하지 않음
/TODO

# build/ 디렉토리에 있는 모든 파일은 무시
build/

# doc/notes.txt 파일은 무시하고 doc/server/arch.txt 파일은 무시하지 않음
doc/*.txt

# doc 디렉토리 아래의 모든 .pdf 파일을 무시
doc/**/*.pdf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Tip&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;GitHub은 다양한 프로젝트에서 자주 사용하는 .gitignore 예제를 관리하고 있다. 어떤 내용을 넣을지 막막하다면 &lt;strong&gt;https://github.com/github/gitignore&lt;/strong&gt; 사이트에서 적당한 예제를 찾을 수 있다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;.gitignore&lt;/strong&gt;를 사용하는 간단한 방식은 하나의 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 최상위 디렉토리에 하나 두고 모든 하위 디렉토리에까지 적용시키는 방식이다. 물론 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 하나만 두는 것이 아니라 하위 디렉토리에도 추가로 둘 수도 있다. &lt;strong&gt;.gitignore&lt;/strong&gt; 정책은 현재 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일이 위치한 디렉토리와 그 하위 디렉토리에 적용된다. (리눅스 커널 소스 저장소에는 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일이 206개나 있음)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;다수의 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 두고 정책을 적용하는 부분은 이 책에서 다루는 범위를 벗어난다. 자세한 내용은 &lt;code class=&quot;highlighter-rouge&quot;&gt;man gitignore&lt;/code&gt;에서 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;6-staged와-unstaged-상태의-변경-내용을-보기&quot;&gt;6. Staged와 Unstaged 상태의 변경 내용을 보기&lt;/h2&gt;

&lt;p&gt;단순히 파일이 변경됐다는 사실이 아니라 어떤 내용이 변경됐는지 살펴보려면 git status 명령이 아니라 git diff 명령을 사용해야 한다. 보통 우리는 ‘수정했지만, 아직 Staged 파일이 아닌 것?’과 ‘어떤 파일이 Staged 상태인지?’가 궁금하기 때문에 git status 명령으로도 충분하다. 더 자세하게 볼 때는 git diff 명령을 사용하는데 Patch처럼 어떤 라인을 추가했고 삭제했는지가 궁금할 때 사용한다. git diff 는 나중에 더 자세히 다룬다.&lt;/p&gt;

&lt;p&gt;README 파일을 수정해서 Staged 상태로 만들고 CONTRIBUTING.md 파일은 그냥 수정만 해둔다. 이 상태에서 git status 명령을 실행하면 아래와 같은 메시지를 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    modified:   README

Changes not staged for commit:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;git diff 명령을 실행하면 수정했지만 아직 staged 상태가 아닌 파일을 비교해 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; git diff
&lt;span class=&quot;gh&quot;&gt;diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/CONTRIBUTING.md
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/CONTRIBUTING.md
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -65,7 +65,8 @@&lt;/span&gt; branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
&lt;span class=&quot;gd&quot;&gt;-merged in.
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.
&lt;/span&gt;
 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 명령은 워킹 디렉토리에 있는 것과 Staging Area에 있는 것을 비교한다. 그래서 수정하고 아직 Stage 하지 않은 것을 보여준다.&lt;/p&gt;

&lt;p&gt;만약 커밋하려고 Staging Area에 넣은 파일의 변경 부분을 보고 싶으면 git diff –staged 옵션을 사용한다. 이 명령은 저장소에 커밋한 것과 Staging Area에 있는 것을 비교한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; git diff --staged
&lt;span class=&quot;gh&quot;&gt;diff --git a/README b/README
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;new file mode 100644
&lt;/span&gt;&lt;span class=&quot;gh&quot;&gt;index 0000000..03902a1
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- /dev/null
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/README
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -0,0 +1 @@&lt;/span&gt;
&lt;span class=&quot;gi&quot;&gt;+My Project
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;꼭 잊지 말아야 할 것이 있는데 git diff 명령은 마지막으로 커밋한 후에 수정한 것들 전부를 보여주지 않는다. git diff 는 Unstaged 상태인 것들만 보여준다. 수정한 파일을 모두 Staging Area에 넣었다면 git diff 명령은 아무것도 출력하지 않는다.&lt;/p&gt;

&lt;p&gt;CONTRIBUTING.md 파일을 Stage 한 후에 다시 수정해도 git diff 명령을 사용할 수 있다. 이때는 Staged 상태인 것과 Unstaged 상태인 것을 비교한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add CONTRIBUTING.md
$ echo '# test line' &amp;gt;&amp;gt; CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;git diff 명령으로 Unstaged 상태인 변경 부분을 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; git diff
&lt;span class=&quot;gh&quot;&gt;diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/CONTRIBUTING.md
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/CONTRIBUTING.md
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -119,3 +119,4 @@&lt;/span&gt; at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
&lt;span class=&quot;gi&quot;&gt;+# test line
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Staged 상태인 파일은 git diff –cached 옵션으로 확인한다. –staged 와 –cached 는 같은 옵션이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; git diff --cached
&lt;span class=&quot;gh&quot;&gt;diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/CONTRIBUTING.md
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/CONTRIBUTING.md
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -65,7 +65,8 @@&lt;/span&gt; branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
&lt;span class=&quot;gd&quot;&gt;-merged in.
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.
&lt;/span&gt;
 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;외부 도구로 비교하기&lt;/strong&gt;&lt;br /&gt;이 책에서는 계속 &lt;strong&gt;git diff&lt;/strong&gt; 명령으로 여기저기서 써 먹는다. 즐겨 쓰거나 결과를 아름답게 보여주는 Diff 도구가 있으면 사용할 수 있다. &lt;strong&gt;git diff&lt;/strong&gt; 대신 &lt;strong&gt;git difftool&lt;/strong&gt; 명령을 사용해서 &lt;strong&gt;emerge&lt;/strong&gt;, &lt;strong&gt;vimdiff&lt;/strong&gt; 같은 도구로 비교할 수 있다. 상용 제품도 사용할 수 있다. &lt;strong&gt;git difftool –tool-help&lt;/strong&gt; 라는 명령은 사용가능한 도구를 보여준다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;7-변경사항-커밋하기&quot;&gt;7. 변경사항 커밋하기&lt;/h2&gt;

&lt;p&gt;수정한 것을 커밋하기 위해 Staging Area에 파일을 정리했다. Unstaged 상태의 파일은 커밋되지 않는다는 것을 기억해야 한다. Git은 생성하거나 수정하고 나서 git add 명령으로 추가하지 않은 파일은 커밋하지 않는다. 그 파일은 여전히 Modified 상태로 남아 있다. 커밋하기 전에 git status 명령으로 모든 것이 Staged 상태인지 확인할 수 있다. 그 후에 git commit 을 실행하여 커밋한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git commit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Git 설정에 지정된 편집기가 실행되고, 아래와 같은 텍스트가 자동으로 포함된다 (아래 예제는 Vim 편집기의 화면이다. 이 편집기는 쉘의 EDITOR 환경 변수에 등록된 편집기이고 보통은 Vim이나 Emacs을 사용한다. 또 시작하기 에서 설명했듯이 git config –global core.editor 명령으로 어떤 편집기를 사용할지 설정할 수 있다).&lt;/p&gt;

&lt;p&gt;편집기는 아래와 같은 내용을 표시한다(아래 예제는 Vim 편집기).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
&quot;.git/COMMIT_EDITMSG&quot; 9L, 283C
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;자동으로 생성되는 커밋 메시지의 첫 라인은 비어 있고 둘째 라인부터 git status 명령의 결과가 채워진다. 커밋한 내용을 쉽게 기억할 수 있도록 이 메시지를 포함할 수도 있고 메시지를 전부 지우고 새로 작성할 수 있다 (정확히 뭘 수정했는지도 보여줄 수 있는데, git commit 에 -v 옵션을 추가하면 편집기에 diff 메시지도 추가된다). 내용을 저장하고 편집기를 종료하면 Git은 입력된 내용(#로 시작하는 내용을 제외한)으로 새 커밋을 하나 완성한다.&lt;/p&gt;

&lt;p&gt;메시지를 인라인으로 첨부할 수도 있다. commit 명령을 실행할 때 아래와 같이 -m 옵션을 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git commit -m &quot;Story 182: Fix benchmarks for speed&quot;
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 첫번째 커밋을 작성해보았다. commit 명령은 몇 가지 정보를 출력하는데 위 예제는 (master) 브랜치에 커밋했고 체크섬은 (463dc4f)이라고 알려준다. 그리고 수정한 파일이 몇 개이고 삭제됐거나 추가된 라인이 몇 라인인지 알려준다.&lt;/p&gt;

&lt;p&gt;Git은 Staging Area에 속한 스냅샷을 커밋한다는 것을 기억해야 한다. 수정은 했지만, 아직 Staging Area에 넣지 않은 것은 다음에 커밋할 수 있다. 커밋할 때마다 프로젝트의 스냅샷을 기록하기 때문에 나중에 스냅샷끼리 비교하거나 예전 스냅샷으로 되돌릴 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;8-staging-area-생략하기&quot;&gt;8. Staging Area 생략하기&lt;/h2&gt;

&lt;p&gt;Staging Area는 커밋할 파일을 정리한다는 점에서 매우 유용하지만 복잡하기만 하고 필요하지 않은 때도 있다. 아주 쉽게 Staging Area를 생략할 수 있다. git commit 명령을 실행할 때 -a 옵션을 추가하면 Git은 Tracked 상태의 파일을 자동으로 Staging Area에 넣는다. 그래서 git add 명령을 실행하는 수고를 덜 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 예제에서는 커밋하기 전에 git add 명령으로 CONTRIBUTING.md 파일을 추가하지 않았다는 점을 눈여겨보자. -a 옵션을 사용하면 모든 파일이 자동으로 추가된다. 편리한 옵션이긴 하지만 주의 깊게 사용해야 한다. 생각 없이 이 옵션을 사용하다 보면 추가하지 말아야 할 변경사항도 추가될 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;9-파일-삭제하기&quot;&gt;9. 파일 삭제하기&lt;/h2&gt;

&lt;p&gt;Git에서 파일을 제거하려면 git rm 명령으로 Tracked 상태의 파일을 삭제한 후에(정확하게는 Staging Area에서 삭제하는 것) 커밋해야 한다. 이 명령은 워킹 디렉토리에 있는 파일도 삭제하기 때문에 실제로 파일도 지워진다.&lt;/p&gt;

&lt;p&gt;Git 명령을 사용하지 않고 단순히 워킹 디렉터리에서 파일을 삭제하고 git status 명령으로 상태를 확인하면 Git은 현재 “Changes not staged for commit” (즉, Unstaged 상태)라고 표시해준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use &quot;git add/rm &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그리고 git rm 명령을 실행하면 삭제한 파일은 Staged 상태가 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    deleted:    PROJECTS.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;커밋하면 파일은 삭제되고 Git은 이 파일을 더는 추적하지 않는다. 이미 파일을 수정했거나 Staging Area에(역주 - Git Index라고도 부른다) 추가했다면 -f 옵션을 주어 강제로 삭제해야 한다. 이 점은 실수로 데이터를 삭제하지 못하도록 하는 안전장치다. 커밋 하지 않고 수정한 데이터는 Git으로 복구할 수 없기 때문이다.&lt;/p&gt;

&lt;p&gt;또 Staging Area에서만 제거하고 워킹 디렉토리에 있는 파일은 지우지 않고 남겨둘 수 있다. 다시 말해서 하드디스크에 있는 파일은 그대로 두고 Git만 추적하지 않게 한다. 이것은 .gitignore 파일에 추가하는 것을 빼먹었거나 대용량 로그 파일이나 컴파일된 파일인 .a 파일 같은 것을 실수로 추가했을 때 쓴다. –cached 옵션을 사용하여 명령을 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rm --cached README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;여러 개의 파일이나 디렉토리를 한꺼번에 삭제할 수도 있다. 아래와 같이 git rm 명령에 file-glob 패턴을 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rm log/\*.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;*&lt;/strong&gt; 앞에 \ 을 사용한 것을 기억하자. 파일명 확장 기능은 쉘에만 있는 것이 아니라 Git 자체에도 있기 때문에 필요하다. 이 명령은 log/ 디렉토리에 있는 .log 파일을 모두 삭제한다. 아래의 예제처럼 할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rm \*~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 명령은 ~ 로 끝나는 파일을 모두 삭제한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;10-파일-이름-변경하기&quot;&gt;10. 파일 이름 변경하기&lt;/h2&gt;

&lt;p&gt;Git은 다른 VCS 시스템과는 달리 파일 이름의 변경이나 파일의 이동을 명시적으로 관리하지 않는다. 다시 말해서 파일 이름이 변경됐다는 별도의 정보를 저장하지 않는다. Git은 똑똑해서 굳이 파일 이름이 변경되었다는 것을 추적하지 않아도 아는 방법이 있다. 파일의 이름이 변경된 것을 Git이 어떻게 알아내는지 살펴보자.&lt;/p&gt;

&lt;p&gt;이렇게 말하고 Git에 mv 명령이 있는 게 좀 이상하겠지만, 아래와 같이 파일 이름을 변경할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git mv file_from file_to
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;잘 동작한다. 이 명령을 실행하고 Git의 상태를 확인해보면 Git은 이름이 바뀐 사실을 알고 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    renamed:    README.md -&amp;gt; README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;사실 git mv 명령은 아래 명령어를 수행한 것과 완전 똑같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mv README.md README
$ git rm README.md
$ git add README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;git mv 명령은 일종의 단축 명령어이다. 이 명령으로 파일 이름을 바꿔도 되고 mv 명령으로 파일 이름을 직접 바꿔도 된다. 단지 git mv 명령은 편리하게 명령을 세 번 실행해주는 것 뿐이다. 어떤 도구로 이름을 바꿔도 상관없다. 중요한 것은 이름을 변경하고 나서 꼭 rm/add 명령을 실행해야 한다는 것 뿐이다.&lt;/p&gt;

&lt;p&gt;[출처]&lt;a href=&quot;https://git-scm.com/book/ko/v2/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B3%A0-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0&quot;&gt;git-scm&lt;/a&gt;&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="GIT" /><category term="기초" /><category term="수정하기" /><category term="저장하기" /><summary type="html"></summary></entry><entry><title type="html">04.GIT 저장소 만들기</title><link href="http://localhost:4000/categories/git/GIT-04-creating-git-repository.html" rel="alternate" type="text/html" title="04.GIT 저장소 만들기" /><published>2019-12-08T10:17:13+00:00</published><updated>2019-12-08T10:17:13+00:00</updated><id>http://localhost:4000/categories/git/GIT-04-creating-git-repository</id><content type="html" xml:base="http://localhost:4000/categories/git/GIT-04-creating-git-repository.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;git의-기초---git-저장소-만들기&quot;&gt;Git의 기초 - Git 저장소 만들기&lt;/h1&gt;

&lt;p&gt;Git에서 자주 사용하는 명령어는 모두 이후에 올리게 될 것이다. 추후 업데이트 되는 내용을 다 읽으면 저장소를 만들고 설정하는 방법, 파일을 추적하거나(Track) 추적을 그만두는 방법, 변경 내용을 Stage 하고 커밋하는 방법을 알게 된다. 파일이나 파일 패턴을 무시하도록 Git을 설정하는 방법, 실수를 쉽고 빠르게 만회하는 방법, 프로젝트 히스토리를 조회하고 커밋을 비교하는 방법, 리모트 저장소에 Push 하고 Pull 하는 방법을 살펴본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-git-저장소-만들기&quot;&gt;1. Git 저장소 만들기&lt;/h2&gt;

&lt;p&gt;주로 다음 주 가지 중 한 가지 방법으로 Git 저장소를 쓰기 시작한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;아직 버전관리를 하지 않는 로컬 디렉토리 하나를 선택해서 Git 저장소를 적용하는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다른 어딘가에서 Git 저장소를 &lt;strong&gt;Clone&lt;/strong&gt; 하는 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;어떤 방법을 사용하든 로컬 디렉토리에 Git 저장소가 준비되면 이제 뭔가 해볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;11-기존-디렉토리를-git-저장소로-만들기&quot;&gt;1.1. 기존 디렉토리를 “Git 저장소”로 만들기&lt;/h3&gt;

&lt;p&gt;버전관리를 하지 아니하는 기존 프로젝트를 Git으로 관리하고 싶은 경우 우선 프로젝트의 디렉토리로 이동한다. 이러한 과정을 처음 해보는 것이라면 시스템마다 조금 다른 점을 주의하자.&lt;/p&gt;

&lt;p&gt;Linux:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd /home/user/my_project
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Mac:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd /Users/user/my_project
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Windows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd /c/user/my_project
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 아래와 같은 명령을 실행한다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령은 &lt;strong&gt;.git&lt;/strong&gt; 이라는 하위 디렉토리를 만든다. &lt;strong&gt;.git&lt;/strong&gt; 디렉토리에는 저장소에 필요한 뼈대 파일(Skeleton)이 들어 있다. 이 명령만으로는 아직 프로젝트의 어떤 파일도 관리하지 않는다. (&lt;strong&gt;.git&lt;/strong&gt; 디렉토리가 막 만들어진 직후에 정확히 어떤 파일이 있는지에 대한 내용은 &lt;strong&gt;Git의 내부&lt;/strong&gt;에서 다룬다)&lt;/p&gt;

&lt;p&gt;Git이 파일을 관리하게 하려면 저장소에 파일을 추가하고 커밋해야 한다. &lt;strong&gt;git add&lt;/strong&gt; 명령으로 파일을 추가하고 &lt;strong&gt;git commit&lt;/strong&gt; 명령으로 커밋한다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add *.c
$ git add LICENSE
$ git commit -m 'initial project version'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;위의 명령어를 통해 *.c로 된 파일을 추가하고, LICENSE 파일을 추가하는 작업을 한 후 에 git commit이 이루어진 것이다. 해당 폴더의 모든 파일을 추가할 경우 아래와 같이 하는 경우가 내 경우에는 더 많다. (단, 제외 파일 목록 관리를 잘해야한다. 추후에 다루겠다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;명령어 몇 개로 순식간에 Git 저장소를 만들고 파일 버전 관리를 시작했다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;12-기존-저장소를-clone-하기&quot;&gt;1.2. 기존 저장소를 Clone 하기&lt;/h3&gt;

&lt;p&gt;다른 프로젝트에 참여하려거나(Contribute) Git 저장소를 복사하고 싶을 때 &lt;strong&gt;git clone&lt;/strong&gt; 명령을 사용한다. 이미 Subversion 같은 VCS에 익숙한 사용자에게는 “checkout” 이 아니라 “clone” 이라는 점이 도드라져 보일 것이다. Git이 Subversion과 다른 가장 큰 차이점은 서버에 있는 거의 모든 데이터를 복사한다는 것이다. &lt;strong&gt;git clone&lt;/strong&gt; 을 실행하면 프로젝트 히스토리를 전부 받아온다. 실제로 서버의 디스크가 망가져도 클라이언트 저장소 중에서 아무거나 하나 가져다가 복구하면 된다(서버에만 적용했던 설정은 복구하지 못하지만 모든 데이터는 복구된다 - 서버에 Git 설치하기에서 좀 더 자세히 다룬다).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;git clone &amp;lt;url&amp;gt;&lt;/strong&gt; 명령으로 저장소를 Clone 한다. &lt;strong&gt;libgit2&lt;/strong&gt; 라이브러리 소스코드를 Clone 하려면 아래과 같이 실행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/libgit2/libgit2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 명령은 “libgit2” 라는 디렉토리를 만들고 그 안에 &lt;strong&gt;.git&lt;/strong&gt; 디렉토리를 만든다. 그리고 저장소의 데이터를 모두 가져와서 자동으로 가장 최신 버전을 Checkout 해 놓는다. &lt;strong&gt;libgit2&lt;/strong&gt; 디렉토리로 이동하면 Checkout으로 생성한 파일을 볼 수 있고 당장 하고자 하는 일을 시작할 수 있다.&lt;/p&gt;

&lt;p&gt;아래과 같은 명령을 사용하여 저장소를 Clone 하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;libgit2&lt;/code&gt;이 아니라 다른 디렉토리 이름으로 Clone 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/libgit2/libgit2 mylibgit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;디렉토리 이름이 &lt;strong&gt;mylibgit&lt;/strong&gt; 이라는 것만 빼면 이 명령의 결과와 앞선 명령의 결과는 같다.&lt;/p&gt;

&lt;p&gt;Git은 다양한 프로토콜을 지원한다. 이제까지는 &lt;strong&gt;https://&lt;/strong&gt; 프로토콜을 사용했지만 &lt;strong&gt;git://&lt;/strong&gt; 를 사용할 수도 있고 &lt;strong&gt;user@server:path/to/repo.git&lt;/strong&gt; 처럼 SSH 프로토콜을 사용할 수도 있다. 자세한 내용은 서버에 Git 설치하기에서 다루며 각 프로토콜의 장단점과 Git 저장소에 접근하는 방법을 설명한다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red;font-size:20px;&quot;&gt; &lt;strong&gt;Git을 시작하기에 매우 중요한 내용이기 때문에 이 내용을 모르고 Git을 시작한다는 것은 거의 불가능하다. 따라서, 본 내용을 반드시 숙지하는 것이 좋다.&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;[출처]&lt;a href=&quot;https://git-scm.com/book/ko/v2/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-Git-%EC%A0%80%EC%9E%A5%EC%86%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0&quot;&gt;git-scm&lt;/a&gt;&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="GIT" /><category term="기초" /><category term="저장소" /><summary type="html"></summary></entry><entry><title type="html">03.GIT 시작하기에 앞서 알면 좋은 것(도움말 보기)</title><link href="http://localhost:4000/categories/git/GIT-03-how-to-use-help.html" rel="alternate" type="text/html" title="03.GIT 시작하기에 앞서 알면 좋은 것(도움말 보기)" /><published>2019-12-08T09:30:13+00:00</published><updated>2019-12-08T09:30:13+00:00</updated><id>http://localhost:4000/categories/git/GIT-03-how-to-use-help</id><content type="html" xml:base="http://localhost:4000/categories/git/GIT-03-how-to-use-help.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;git을-사용하기-앞서-알면-좋은-내용&quot;&gt;Git을 사용하기 앞서 알면 좋은 내용&lt;/h1&gt;

&lt;h2 id=&quot;git-도움말-보기&quot;&gt;Git 도움말 보기&lt;/h2&gt;

&lt;p&gt;명령어에 대한 도움말이 필요할 때 도움말을 보는 방법은 두 가지로 동일한 결과를 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git help &amp;lt;verb&amp;gt;
$ man git-&amp;lt;verb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예를 들어 아래와 같이 실행하면 &lt;strong&gt;git config&lt;/strong&gt; 명령에 대한 도움말을 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git help config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;도움말은 언제 어디서나 볼 수 있다. 오프라인으로도 볼 수 있다. 도움말과 이 책으로 부족하면 다른 사람의 도움을 받는 것이 필요하다. Freenode IRC 서버(irc.freenode.net)에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;#git&lt;/code&gt; 이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;#github&lt;/code&gt; 채널로 찾아가라. 이 채널에는 보통 수백 명의 사람이 접속해 있다. 모두 Git에 대해 잘 알고 있다. 기꺼이 도와줄 것이다.&lt;/p&gt;

&lt;p&gt;Git 명령을 사용하기 위해 매우 자세한 도움말 전체를 볼 필요 없이 각 명령에서 사용할 수 있는 옵션들에 대해서 간략히 살펴볼수도 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;-h&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;--help&lt;/code&gt; 옵션을 사용하면 다음과 같이 Git 명령에서 사용할 수 있는 옵션들에 대한 간단한 도움말을 출력한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/git/git_help_config.png&quot; title=&quot;git_help_config&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add -h
usage: git add [&amp;lt;options&amp;gt;] [--] &amp;lt;pathspec&amp;gt;...

    -n, --dry-run         dry run
    -v, --verbose         be verbose

    -i, --interactive     interactive picking
    -p, --patch           select hunks interactively
    -e, --edit            edit current diff and apply
    -f, --force           allow adding otherwise ignored files
    -u, --update          update tracked files
    -N, --intent-to-add   record only the fact that the path will be added later
    -A, --all             add changes from all tracked and untracked files
    --ignore-removal      ignore paths removed in the working tree (same as --no-all)
    --refresh             don't add, only refresh the index
    --ignore-errors       just skip files which cannot be added because of errors
    --ignore-missing      check if - even missing - files are ignored in dry run
    --chmod &amp;lt;(+/-)x&amp;gt;      override the executable bit of the listed files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[출처]&lt;a href=&quot;https://git-scm.com/book/ko/v2/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EB%8F%84%EC%9B%80%EB%A7%90-%EB%B3%B4%EA%B8%B0&quot;&gt;git-scm&lt;/a&gt;&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="GIT" /><category term="시작하기" /><category term="도움말" /><summary type="html"></summary></entry><entry><title type="html">02.GIT 초기 설정하기</title><link href="http://localhost:4000/categories/git/GIT-02-initial-settings.html" rel="alternate" type="text/html" title="02.GIT 초기 설정하기" /><published>2019-12-07T22:17:13+00:00</published><updated>2019-12-07T22:17:13+00:00</updated><id>http://localhost:4000/categories/git/GIT-02-initial-settings</id><content type="html" xml:base="http://localhost:4000/categories/git/GIT-02-initial-settings.html">&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;git-시작하기-위한-설정하기&quot;&gt;Git 시작하기 위한 설정하기&lt;/h1&gt;

&lt;h2 id=&quot;1-git-최초-설정&quot;&gt;1. Git 최초 설정&lt;/h2&gt;

&lt;p&gt;Git을 설치하고 나면 Git의 사용 환경을 적절하게 설정해 주어야 한다. 환경 설정은 한 컴퓨터에서 한 번만 하면 된다. 설정한 내용은 Git을 업그레이드해도 유지된다. 언제든지 다시 바꿀 수 있는 명령어도 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘git config’라는 도구로 설정 내용을 확인하고 변경할 수 있다. Git은 이 설정에 따라 동작한다. 이때 사용하는 설정 파일은 세 가지나 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/gitconfig 파일: 시스템의 모든 사용자와 모든 저장소에 적용되는 설정이다. git config –system 옵션으로 이 파일을 읽고 쓸 수 있다. (이 파일은 시스템 전체 설정파일이기 때문에 수정하려면 시스템의 관리자 권한이 필요하다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;~/.gitconfig, ~/.config/git/config 파일: 특정 사용자(즉 현재 사용자)에게만 적용되는 설정이다. git config –global 옵션으로 이 파일을 읽고 쓸 수 있다. 특정 사용자의 모든 저장소 설정에 적용된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;.git/config : 이 파일은 Git 디렉토리에 있고 특정 저장소(혹은 현재 작업 중인 프로젝트)에만 적용된다. –local 옵션을 사용하면 이 파일을 사용하도록 지정할 수 있다. 하지만 기본적으로 이 옵션이 적용되어 있다. (당연히, 이 옵션을 적용하려면 Git 저장소인 디렉토리로 이동 한 후 적용할 수 있다.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;각 설정은 역순으로 우선시 된다. 그래서 &lt;strong&gt;.git/config&lt;/strong&gt; 가 &lt;strong&gt;/etc/gitconfig&lt;/strong&gt; 보다 우선한다.&lt;/p&gt;

&lt;p&gt;Windows에서는 &lt;strong&gt;$HOME&lt;/strong&gt; 디렉토리에서 &lt;strong&gt;.gitconfig&lt;/strong&gt; 파일을 찾는다(아마도 &lt;strong&gt;C:\Users\$USER&lt;/strong&gt; 디렉토리). Windows에서도 &lt;strong&gt;/etc/gitconfig&lt;/strong&gt; 파일은 그 경로에서 찾는다. 이 경로는 아마도 MSys 루트의 상대경로일 텐데, MSys 루트는 인스톨러로 Git을 Windows에 설치할 때 결정된다. Git for Windows 2.x 버전에서는 조금 다르다. Windows XP 사용자는 &lt;strong&gt;C:\Documents and Settings\All Users\Application Data\Git\config&lt;/strong&gt; 디렉토리에서 찾을 수 있고 Windows Vista 이후 버전 사용자는 &lt;strong&gt;C:\ProgramData\Git\config&lt;/strong&gt; 에서 찾을 수 있다. 이 시스템 설정 파일의 경로는 &lt;strong&gt;git config -f &amp;lt;file&amp;gt;&lt;/strong&gt; 명령으로 변경할 수 있다. 관리자 권한이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2--사용자-정보-설정&quot;&gt;2.  사용자 정보 설정&lt;/h2&gt;

&lt;p&gt;Git을 설치하고 나서 가장 먼저 해야 하는 것은 사용자이름과 이메일 주소를 설정하는 것이다. Git은 커밋할 때마다 이 정보를 사용한다. 한 번 커밋한 후에는 정보를 변경할 수 없다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git config --global user.name &quot;lsirikh&quot;
$ git config --global user.email lsirikh@naver.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다시 말하자면 &lt;strong&gt;–global&lt;/strong&gt; 옵션으로 설정하는 것은 딱 한 번만 하면 된다. 해당 시스템에서 해당 사용자가 사용할 때는 이 정보를 사용한다. 만약 프로젝트마다 다른 이름과 이메일 주소를 사용하고 싶으면 &lt;strong&gt;–global&lt;/strong&gt; 옵션을 빼고 명령을 실행한다.&lt;/p&gt;

&lt;p&gt;[GUI 도구들은 처음 실행할 때 이 설정을 묻는다.]&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-편집기-설정&quot;&gt;3. 편집기 설정&lt;/h2&gt;

&lt;p&gt;사용자 정보를 설정하고 나면 Git에서 사용할 텍스트 편집기를 고른다. 기본적으로 Git은 시스템의 기본 편집기를 사용한다.&lt;/p&gt;

&lt;p&gt;하지만, Emacs 같은 다른 텍스트 편집기를 사용할 수 있고 아래와 같이 실행하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;꼭 이것을 쓰라는 얘기는 아니고 바꿀수 있는 참고로 활용&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git config --global core.editor emacs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Windows 사용자라면 다른 텍스트 편집기를 사용할 수 있다. 실행파일의 전체 경로를 설정해주면 된다. 실행파일의 전체 경로는 사용하는 편집기에 따라 다르다.&lt;/p&gt;

&lt;p&gt;Windows 환경에서 많이 사용되는 Notepad &lt;strong&gt;편집기의 경우 주로 32비트 버전을 사용하게 된다. 현재 기준으로 64비트 버전을 사용하면 동작하지 않는 플러그인이 많다. 32비트 Windows 시스템이거나, 64비트 Windows 시스템에서 64비트 Notepad&lt;/strong&gt;을 설치했다면 다음과 같이 설정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git config --global core.editor &quot;'C:/Program Files/Notepad++/notepad++.exe' -multiInst -nosession&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;64비트 Windows 시스템에서 32비트 Notepad++을 설치했다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Program Files (x86)&lt;/code&gt;에 설치된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git config --global core.editor &quot;'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -nosession&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Note&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Vim과 Emacs, Notepad++은 꽤 인기 있는 편집기로 개발자들이 즐겨 사용한다. Mac이나 Linux 같은 Unix 시스템, Windows 시스템에서 사용 가능하다. 여기서 소개하는 편집기들이 불편해서 다른 편집기를 사용하고자 한다면 해당 편집기를 Git 편집기로 설정하는 방법을 찾아봐야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Warning&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;자신의 편집기를 설정하지 않으면 갑자기 실행된 편집기에 당황할 수 있다. 그땐 당황하지 말고 편집기를 그냥 종료하면 Git 명령을 취소할 수 있다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-설정-확인&quot;&gt;4. 설정 확인&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;git config –list&lt;/strong&gt; 명령을 실행하면 설정한 모든 것을 보여주어 바로 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git config --list
user.name=John Doe
user.email=johndoe@example.com
color.status=auto
color.branch=auto
color.interactive=auto
color.diff=auto
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Git은 같은 키를 여러 파일(&lt;strong&gt;/etc/gitconfig&lt;/strong&gt; 와 &lt;strong&gt;~/.gitconfig&lt;/strong&gt; 같은)에서 읽기 때문에 같은 키가 여러 개 있을 수도 있다. 그러면 Git은 나중 값을 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;git config &amp;lt;key&amp;gt;&lt;/strong&gt; 명령으로 Git이 특정 Key에 대해 어떤 값을 사용하는지 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git config user.name
lsirikh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Note&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Git이 설정된 값을 읽을 때 여러 파일에서 동일한 키에 대해 다른 값을 설정하고 있을 수 있다. 값이 기대한 값과 다를 수 있는데 값만 보고 쉽게 그 원인을 찾을 수 없다. 이 때 키에 설정된 값이 어디에서 설정되었는지 확인할 수 있는데 다음과 같은 명령으로 어떤 파일로부터 설정된 값인지를 확인할 수 있다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git config --show-origin rerere.autoUpdate
file:/home/lsirikh/.gitconfig	false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[출처]&lt;a href=&quot;https://git-scm.com/book/ko/v2/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-Git-%EC%B5%9C%EC%B4%88-%EC%84%A4%EC%A0%95&quot;&gt;git-scm&lt;/a&gt;&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="GIT" /><category term="initial" /><category term="commit" /><category term="초기" /><category term="커밋" /><summary type="html"></summary></entry><entry><title type="html">01.GIT이란 무엇인가?</title><link href="http://localhost:4000/categories/git/GIT-01-introduction.html" rel="alternate" type="text/html" title="01.GIT이란 무엇인가?" /><published>2019-12-07T19:00:13+00:00</published><updated>2019-12-07T19:00:13+00:00</updated><id>http://localhost:4000/categories/git/GIT-01-introduction</id><content type="html" xml:base="http://localhost:4000/categories/git/GIT-01-introduction.html">&lt;h2 id=&quot;1-git-이란-무엇인가&quot;&gt;1. Git 이란 무엇인가???&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/git/480px-Octocat_GitHub_Mascot.png&quot; width=&quot;40%&quot; height=&quot;40%&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/git/git.png&quot; title=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;GitHub를 이해하려면 먼저 Git을 이해해야합니다. Git은 리눅스를 만든 사람인 Linus Torvalds에 의해 시작된 오픈 소스 버전 관리 시스템입니다. Git은 Subversion , CVS 및 Mercurial 과 같은 다른 버전 제어 시스템과 유사합니다.&lt;/p&gt;

&lt;p&gt;Git은 버전 관리 시스템이지만 무엇일까?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;예를 들어, 개발자가 무언가 앱을 만들면 코드가 지속적으로 변경되어 첫 번째 공식 (베타 이외) 릴리스 이후에 새 버전이 릴리스됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;버전 제어 시스템은 이러한 개정을 똑바로 유지하여 수정 사항을 중앙 저장소에 저장합니다. 이를 통해 개발자는 새로운 버전의 소프트웨어를 다운로드하고 변경하며 최신 버전을 업로드 할 수 있으므로 쉽게 협업 할 수 있습니다. 모든 개발자는 이러한 새로운 변경 사항을 보고 다운로드하여 제공 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;마찬가지로, 프로젝트 개발과 관련이 없는 사람들도 공개된 GIT ​​파일을 다운로드하여 사용할 수 있습니다. Git이 시작된 배경이 Linux 환경이기 때문에 Linux에서 좀 더 활용도가 용이 할 수 있지만, 현재 Windows나 OS X에도 많은 지원이 되는 관계로 이제는 크게 무관한 것으로 보입니다.&lt;/p&gt;

&lt;p&gt;Git은 사용 가능한 다른 시스템에 비해 여러 가지 장점이 있기 때문에 대부분의 개발자가 선호하는 버전 제어 시스템입니다. 파일 변경 사항을보다 효율적으로 저장하고 파일 무결성을 향상시킵니다. 세부 사항을 알고 싶다면  Git 기본 페이지  에 Git 작동 방식에 대한 자세한 설명이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;2-github의-허브&quot;&gt;2. GitHub의 “허브”&lt;/h2&gt;

&lt;p&gt;Git와 함께 사용하여 더 나은 버전 제어 시스템을 확립했습니다. 그렇다면 GitHub는 무엇일까요? Git은 명령 줄 도구이지만 Git revolve와 관련된 모든 것은 프로젝트와 관련된 내용을 저장하는 허브 (GitHub.com)입니다.&lt;/p&gt;

&lt;h2 id=&quot;3-repository-저장소&quot;&gt;3. repository (저장소)&lt;/h2&gt;

&lt;p&gt;repository (일반적으로 “repo”로 약칭)는 특정 프로젝트의 모든 파일이 저장되는 위치입니다. 각 프로젝트에는 자체 저장소가 있으며 고유 한 URL로 액세스 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/git/repository_example.png&quot; title=&quot;리포지토리 저장소&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-fork&quot;&gt;4. Fork&lt;/h2&gt;

&lt;p&gt;“Forking”(발음주의;뽀킹아님)은 이미 존재하는 다른 프로젝트를 기반으로 새 프로젝트를 만들 때 사용합니다. 이것은 프로그램 및 기타 프로젝트의 추가 개발을 손쉽게 할 수 있는 굉장히 놀라운 컨셉인 것 같습니다. GitHub에서 기여하고 싶은 프로젝트를 찾으면 저장소(Repo)를 Fork 하고 원하는대로 변경하고 수정 된 프로젝트를 새 Repo로 릴리스 할 수 있습니다. 새 프로젝트를 작성하기 위해 Fork(분기) 한 원래 저장소가 업데이트되면 해당 업데이트를 현재 분기에 쉽게 추가 할 수 있습니다. 분기 추가의 권한은 원천 개발자에게 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;5-pull&quot;&gt;5. Pull&lt;/h2&gt;

&lt;p&gt;어떤 개발자가 Repository(repo)를 Fork(분기)하고 프로젝트를 크게 수정 한 후 원래 Repository 주인 혹은 개발자가 이를 인정해주고 원래 프로젝트에 참여시켜주기 원할 수도 있습니다. 그럴 경우 풀 요청을 하면 프로젝트에 참여가 가능합니다. 물론 원본 Repository(이하 리포지토리)의 작성자는 자신의 작업을보고 공식 프로젝트에 수락할지 여부를 선택할 수 있습니다. Pull 요청을 발행 할 때마다 GitHub는 사용자와 기본 프로젝트 관리자가 통신 할 수있는 완벽한 수단을 제공합니다.&lt;/p&gt;

&lt;h2 id=&quot;6-social-networking&quot;&gt;6. Social networking&lt;/h2&gt;

&lt;p&gt;사회적 네트워킹 측면에서 GitHub가 가장 강력한 특징을 지닌듯 합니다. 특히, GitHub가 가지는 다양한 특징과 장점을 압도하는 가장 중요한 점이기도 합니다. GitHub의 각 사용자는 이력서처럼 작동하는 자체 프로필을 가지고 있으며 과거 작업 및 풀 요청을 통해 다른 프로젝트에 대한 기여를 보여줍니다. 한마디로 기여도에 무임승차자가 없고, 기여도로 평가할 수 있는 중요한 지표를 제공해줍니다.&lt;/p&gt;

&lt;p&gt;GitHub를 통해 프로젝트 revision은 공개적으로 논의 될 수 있고, 많은 전문가들이 해당 프로젝트를 발전시키기 위해 지식을 제공하고 협력 할 수 있습니다. GitHub가 등장하기 전에, 어떤 프로젝트에 관심이있는 개발자는 대개 프로젝트 리딩 개발자와 연락 할 수있는 방법을 수소문 한 후, 자신의 신뢰도와 신력을 입증하여야만 참여가능 했으리라 생각됩니다. 아마도 너무나 높은 난관과 진입장벽으로 협업은 거의 불가능 했던 것 같습니다. 그러나 GitHub는 일종의 협력과 상생의 헤게모니를 열었다는 측면에서 굉장한 사회적 충격을 주는 듯 합니다.&lt;/p&gt;

&lt;h2 id=&quot;7-changelogs&quot;&gt;7. Changelogs&lt;/h2&gt;

&lt;p&gt;여러 사람이 한 프로젝트에서 공동 작업 할 때 해당 파일이 저장되는 대상,시기 및 위치를 변경 한 수정본을 추적하기가 어렵습니다. GitHub는 리포지토리에 푸시 된 모든 변경 사항을 추적하여이 문제를 처리합니다.&lt;/p&gt;

&lt;p&gt;[출처]&lt;a href=&quot;https://www.howtogeek.com/180167/htg-explains-what-is-github-and-what-do-geeks-use-it-for/&quot;&gt;howtogeek&lt;/a&gt;&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="GIT" /><category term="introduction" /><summary type="html">1. Git 이란 무엇인가???</summary></entry><entry><title type="html">04.ROS를 GUI 기반 IDE 툴 qt creator 설치(우분투 16.04 Kinetic Kame)</title><link href="http://localhost:4000/categories/ros/ROS-04-ros-roscore-qt-creator-copy.html" rel="alternate" type="text/html" title="04.ROS를 GUI 기반 IDE 툴 qt creator 설치(우분투 16.04 Kinetic Kame)" /><published>2019-12-06T22:12:13+00:00</published><updated>2019-12-06T22:12:13+00:00</updated><id>http://localhost:4000/categories/ros/ROS-04-ros-roscore-qt-creator%20copy</id><content type="html" xml:base="http://localhost:4000/categories/ros/ROS-04-ros-roscore-qt-creator-copy.html">&lt;h2 id=&quot;1-qt-creator란&quot;&gt;1. Qt Creator란?&lt;/h2&gt;

&lt;p&gt;Qt Creator는 Qt GUI 애플리케이션 개발 프레임 워크 용 SDK의 일부인 크로스 플랫폼 C ++, JavaScript 및 QML 통합 개발 환경입니다. 시각적 디버거와 통합 GUI 레이아웃 및 양식 디자이너가 포함되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/QtProject-creator-icon.png&quot; title=&quot;QT logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Qt는 컴퓨터 프로그래밍에서 GUI 프로그램 개발에 널리 쓰이는 크로스 플랫폼 프레임워크이다. 서버용 콘솔과 명령 줄 도구와 같은 비GUI 프로그램 개발에도 사용된다. 그래픽 사용자 인터페이스를 사용하는 경우에는 Qt를 위젯 툴킷으로 분류한다. 회사 내부에서는 Qt를 “cute”로 발음하고 있으며 비공식적으로는 “큐티”로 발음한다. Qt는 KDE, Qtopia, OPIE에 이용되고 있다,&lt;/p&gt;

&lt;p&gt;노르웨이 회사 트롤텍에 의해서 개발되었다. 2008년 1월에는 노키아에 인수되었다.[2] 이후, 2012년 8월에 핀란드 회사 Digia에 인수되었다.[3]&lt;/p&gt;

&lt;p&gt;Qt는 C++를 주로 사용하지만, 파이썬, 루비, C, 펄, 파스칼과도 연동된다. 수많은 플랫폼에서 동작하며, 상당히 좋은 국제화를 지원한다. SQL 데이터베이스 접근, XML 처리, 스레드 관리, 단일 크로스 플랫폼 파일 관리 API를 제공한다.&lt;/p&gt;

&lt;p&gt;[출처] &lt;a href=&quot;https://ko.wikipedia.org/wiki/Qt_(%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC)&quot;&gt;위키백과&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-qt-creator-설치하기&quot;&gt;2. Qt Creator 설치하기&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install qtcreator
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;리눅스가 좋은 점은 바로 이런 apt-get install이란 간편한 방법으로 설치가 가능하다는 점이다.&lt;/p&gt;

&lt;p&gt;일단 설치하고 실행하면 다음과 같이 나오는 것을 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/qtcreator_ide.png&quot; title=&quot;Qt 크리에이터 실행화면&quot; /&gt;&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="ROS" /><category term="qt" /><category term="creator" /><summary type="html">1. Qt Creator란?</summary></entry></feed>