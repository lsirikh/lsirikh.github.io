<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-12-17T14:31:02+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">로봇을 배우기 위한 지식 창고</title><subtitle>로봇을 배우기 위한 지식 창고</subtitle><author><name>Kiho Lee</name></author><entry><title type="html">12.ROS 파일 시스템</title><link href="http://localhost:4000/categories/ros/ROS-12-file-system.html" rel="alternate" type="text/html" title="12.ROS 파일 시스템" /><published>2019-12-17T00:00:00+00:00</published><updated>2019-12-17T00:00:00+00:00</updated><id>http://localhost:4000/categories/ros/ROS-12-file-system</id><content type="html" xml:base="http://localhost:4000/categories/ros/ROS-12-file-system.html">&lt;h2 id=&quot;1-파일-구성&quot;&gt;1. 파일 구성&lt;/h2&gt;

&lt;p&gt;ROS에서 소프트웨어 구성을 위한 기본 단위는 패키지(package)로써 ROS의 응용프로그램은 패키지 단위로 개발된다.&lt;/p&gt;

&lt;p&gt;각 패키지에는 이름, 작성자, 라이센스 및 종속 패키지를 포함하여 패키지에 대한 정보가 들어있는 XML 파일인 &lt;code class=&quot;highlighter-rouge&quot;&gt;package.xml&lt;/code&gt;이 포함되어 있다. 또한, ROS 빌드 시스템 인 Catkin은  CMake를 이용하고 있어서 패키지 폴더의 &lt;code class=&quot;highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;를 사용하여 빌드 환경을 설명한다. 그리고 패키지는 노드의 소스 코드와 노드 간의 메시지 통신을 위한 메시지 파일로 구성된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ROS 패키지를 설치하는 방법에는 두 가지가 있다. 첫 번째는 빌드 프로세스없이 즉시 실행할 수 있는 바이너리 형식으로 제공된 패키지를 설치하는 것이다. 두 번째는 사용자가 패키지의 소스 코드를 다운로드하여 설치하기 전에 빌드하는 것이다. 패키지를 수정하거나 소스 코드의 내용을 확인하려면 두 번째 설치 방법을 사용할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다음은 TurtleBot3 패키지의 예이며 두 가지 설치 방법의 차이점을 설명한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;바이너리 설치 방법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install ros-kinetic-turtlebot3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;소스코드 설치 방법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd ~/catkin_ws/src
$ git clone https://github.com/ROBOTIS-GIT/turtlebot3.git
$ git clone https://github.com/ROBOTIS-GIT/turtlebot3_msgs.git
$ cd ~/catkin_ws/
$ catkin_make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-설치-폴더&quot;&gt;2. 설치 폴더&lt;/h2&gt;

&lt;p&gt;ROS는 다음과 같은 폴더에 설치를 하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;opt/ros/[버전이름]&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;kinetic kame 버전은 ‘/opt/ros/kinetic’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리 및 파일 구성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_install_folder_configuration.png&quot; title=&quot;ROS 디렉토리 및 파일 구성 &quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리 특징&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;/bin        - 실행 가능한 바이너리 파일&lt;/li&gt;
  &lt;li&gt;/etc        - ROS 및 catkin 관련 설정 파일&lt;/li&gt;
  &lt;li&gt;/include    - 헤더 파일&lt;/li&gt;
  &lt;li&gt;/lib        - 라이브러리 파일&lt;/li&gt;
  &lt;li&gt;/share      - ROS 패키지&lt;/li&gt;
  &lt;li&gt;env.*       - 환경설정 파일&lt;/li&gt;
  &lt;li&gt;setup.*     - 환경설정 파일&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-작업-폴더&quot;&gt;3. 작업 폴더&lt;/h2&gt;

&lt;p&gt;대부분의 프로그램이나 프레임워크에서 그렇듯이 작업폴더는 사용자가 원하는 곳에 생성이 가능하다. 하지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;~/catkin_ws/&lt;/code&gt;를 작업폴더로 지정하고 ROS를 작성하도록 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;작업폴더 경로 : &lt;code class=&quot;highlighter-rouge&quot;&gt;home/memaker/catkin_ws/&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리 및 파일 구성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_workspace_folder_configuration.png&quot; title=&quot;ROS workspace 디렉토리 및 파일 구성 &quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리 특징&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;작업 폴더는 사용자가 작성한 패키지와 공개된 다른 개발자의 패키지를 저장하고 빌드하는 공간을 활용된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;/build   - 빌드 관련 파일&lt;/li&gt;
  &lt;li&gt;/devel   - msg, srv 헤더파일 과 사용자 패키지 라이브러리, 실행 파일&lt;/li&gt;
  &lt;li&gt;/src     - 사용자 패키지&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-사용자-패키지&quot;&gt;4. 사용자 패키지&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/catkin_ws/src&lt;/code&gt;폴더는 사용자 소스 코드를위한 공간이다. 이 폴더에서 다른 개발자가 개발한 자체 ROS 패키지 또는 패키지를 저장하고 빌드할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리 및 파일 구성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_user_package_folder_configuration.png&quot; title=&quot;ROS 사용자 패키지 디렉토리 및 파일 구성 &quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리 특징&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;/include         - 헤더파일&lt;/li&gt;
  &lt;li&gt;/launch          - roslaunch에 사용되는 launch 파일&lt;/li&gt;
  &lt;li&gt;/node            - rospy용 스크립터&lt;/li&gt;
  &lt;li&gt;/msg             - 메시지 파일&lt;/li&gt;
  &lt;li&gt;/src             - 소스코드 파일&lt;/li&gt;
  &lt;li&gt;/srv             - 서비스 파일&lt;/li&gt;
  &lt;li&gt;CMakeLists.txt   - 빌드 설정 파일&lt;/li&gt;
  &lt;li&gt;Package.xml      - 패키지 설정 파일&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;출처:[ROS_Robot_Programming_EN]&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="ROS" /><category term="파일시스템" /><summary type="html">1. 파일 구성</summary></entry><entry><title type="html">13.ROS 빌드 시스템</title><link href="http://localhost:4000/categories/ros/ROS-13-build-system.html" rel="alternate" type="text/html" title="13.ROS 빌드 시스템" /><published>2019-12-17T00:00:00+00:00</published><updated>2019-12-17T00:00:00+00:00</updated><id>http://localhost:4000/categories/ros/ROS-13-build-system</id><content type="html" xml:base="http://localhost:4000/categories/ros/ROS-13-build-system.html">&lt;h2 id=&quot;1-들어가며&quot;&gt;1. 들어가며&lt;/h2&gt;

&lt;p&gt;ROS 빌드 시스템은 기본적으로 CMake(Cross Platform Make)를 사용하며, 빌드 환경은 패키지 폴더의 &lt;code class=&quot;highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;파일에 설명되어 있다.&lt;/p&gt;

&lt;p&gt;ROS에서 CMake를 사용하는 이유는 여러 플랫폼에서 ROS 패키지를 빌드 할 수 있기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;2-패키지-만들기&quot;&gt;2. 패키지 만들기&lt;/h2&gt;

&lt;p&gt;다음과 같은 명령어를 통해 패키지를 생성할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ catkin_create_pkg [PACKAGE_NAME] [DEPENDENT_PACKAGE_1] [DEPENDENT_PACKAGE_N]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;catkin_create_pkg&lt;/code&gt;명령은 Cake빌드 시스템에 필요한 &lt;code class=&quot;highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;및 &lt;code class=&quot;highlighter-rouge&quot;&gt;package.xml&lt;/code&gt;파일이 포함 된 패키지 폴더를 만든다.&lt;/p&gt;

&lt;p&gt;다음과 같이 입력하고, 실행하면, 패키지를 생성할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cs
~/catkin_ws/src$ 
~/catkin_ws/src$ catkin_create_pkg my_first_ros_pkg std_msgs roscpp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;만들 패키지 이름은‘my_first_ros_pkg’이다. ROS의 패키지 이름은 모두 소문자 여야하며 공백을 포함해서는 안된다. 이름 지정 지침에서는 대시(-) 또는 공백 대신 각 단어 사이에 &lt;strong&gt;밑줄(_)&lt;/strong&gt;을 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std_msgs&lt;/code&gt; 및 &lt;code class=&quot;highlighter-rouge&quot;&gt;roscpp&lt;/code&gt;는 이전에 선택적 종속 패키지로 추가되었다.
명령. 즉, ROS의 표준 메시지 패키지 인 &lt;code class=&quot;highlighter-rouge&quot;&gt;std_msgs&lt;/code&gt;와 ROS에서 C/C++를 사용하는 데 필요한 클라이언트 라이브러리 인 &lt;code class=&quot;highlighter-rouge&quot;&gt;roscpp&lt;/code&gt;가 패키지를 작성하기 전에 설치되어 있어야한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/catkin_ws/src$ cd my_first_ros_pkg
~/catkin_ws/src$ ls
include 			 → Include Folder
src 				 → Source Code Folder
CMakeLists.txt 		 → Build Configuration File
package.xml 		 → Package Configuration File
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_my_first_package.png&quot; title=&quot;ROS 패키지 생성 &quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-패키지-내용-살펴보기&quot;&gt;3. 패키지 내용 살펴보기&lt;/h2&gt;

&lt;p&gt;ROS의 필수 설정 파일 중 하나인 &lt;code class=&quot;highlighter-rouge&quot;&gt;package.xml&lt;/code&gt;은 패키지의 정보를 담는 XML 파일로 패키지의 이름, 저작자, 라이센스, 의존성 패키지 등을 기술하고 있다.&lt;/p&gt;

&lt;p&gt;다음은 생성된 &lt;code class=&quot;highlighter-rouge&quot;&gt;package.xml&lt;/code&gt;파일을 그대로 가져온 내용이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;package&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;format=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;my_first_ros_pkg&lt;span class=&quot;nt&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;0.0.0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;description&amp;gt;&lt;/span&gt;The my_first_ros_pkg package&lt;span class=&quot;nt&quot;&gt;&amp;lt;/description&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- One maintainer tag required, multiple allowed, one person per tag --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Example:  --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- &amp;lt;maintainer email=&quot;jane.doe@example.com&quot;&amp;gt;Jane Doe&amp;lt;/maintainer&amp;gt; --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;maintainer&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;email=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memaker@todo.todo&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;memaker&lt;span class=&quot;nt&quot;&gt;&amp;lt;/maintainer&amp;gt;&lt;/span&gt;


  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- One license tag required, multiple allowed, one license per tag --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Commonly used license strings: --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!--   BSD, MIT, Boost Software License, GPLv2, GPLv3, LGPLv2.1, LGPLv3 --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;license&amp;gt;&lt;/span&gt;TODO&lt;span class=&quot;nt&quot;&gt;&amp;lt;/license&amp;gt;&lt;/span&gt;


  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Url tags are optional, but multiple are allowed, one per tag --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Optional attribute type can be: website, bugtracker, or repository --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Example: --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- &amp;lt;url type=&quot;website&quot;&amp;gt;http://wiki.ros.org/my_first_ros_pkg&amp;lt;/url&amp;gt; --&amp;gt;&lt;/span&gt;


  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Author tags are optional, multiple are allowed, one per tag --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Authors do not have to be maintainers, but could be --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Example: --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- &amp;lt;author email=&quot;jane.doe@example.com&quot;&amp;gt;Jane Doe&amp;lt;/author&amp;gt; --&amp;gt;&lt;/span&gt;


  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- The *depend tags are used to specify dependencies --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Dependencies can be catkin packages or system dependencies --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Examples: --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Use depend as a shortcut for packages that are both build and exec dependencies --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!--   &amp;lt;depend&amp;gt;roscpp&amp;lt;/depend&amp;gt; --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!--   Note that this is equivalent to the following: --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!--   &amp;lt;build_depend&amp;gt;roscpp&amp;lt;/build_depend&amp;gt; --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!--   &amp;lt;exec_depend&amp;gt;roscpp&amp;lt;/exec_depend&amp;gt; --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Use build_depend for packages you need at compile time: --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!--   &amp;lt;build_depend&amp;gt;message_generation&amp;lt;/build_depend&amp;gt; --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Use build_export_depend for packages you need in order to build against this package: --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!--   &amp;lt;build_export_depend&amp;gt;message_generation&amp;lt;/build_export_depend&amp;gt; --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Use buildtool_depend for build tool packages: --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!--   &amp;lt;buildtool_depend&amp;gt;catkin&amp;lt;/buildtool_depend&amp;gt; --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Use exec_depend for packages you need at runtime: --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!--   &amp;lt;exec_depend&amp;gt;message_runtime&amp;lt;/exec_depend&amp;gt; --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Use test_depend for packages you need only for testing: --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!--   &amp;lt;test_depend&amp;gt;gtest&amp;lt;/test_depend&amp;gt; --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Use doc_depend for packages you need only for building documentation: --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!--   &amp;lt;doc_depend&amp;gt;doxygen&amp;lt;/doc_depend&amp;gt; --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;buildtool_depend&amp;gt;&lt;/span&gt;catkin&lt;span class=&quot;nt&quot;&gt;&amp;lt;/buildtool_depend&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;build_depend&amp;gt;&lt;/span&gt;roscpp&lt;span class=&quot;nt&quot;&gt;&amp;lt;/build_depend&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;build_depend&amp;gt;&lt;/span&gt;std_msgs&lt;span class=&quot;nt&quot;&gt;&amp;lt;/build_depend&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;build_export_depend&amp;gt;&lt;/span&gt;roscpp&lt;span class=&quot;nt&quot;&gt;&amp;lt;/build_export_depend&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;build_export_depend&amp;gt;&lt;/span&gt;std_msgs&lt;span class=&quot;nt&quot;&gt;&amp;lt;/build_export_depend&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;exec_depend&amp;gt;&lt;/span&gt;roscpp&lt;span class=&quot;nt&quot;&gt;&amp;lt;/exec_depend&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;exec_depend&amp;gt;&lt;/span&gt;std_msgs&lt;span class=&quot;nt&quot;&gt;&amp;lt;/exec_depend&amp;gt;&lt;/span&gt;


  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- The export tag contains other, unspecified, tags --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;export&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Other tools can request additional information be placed here --&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/export&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/package&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;?xml&amp;gt;&lt;/code&gt;                - 문서 문법을 정의하는 문구로 아래의 내용은 xml 버전 1.0을 따르고 있다는 것을 표시한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;package&amp;gt;&lt;/code&gt;             - 이 구문부터 맨 끝의 &amp;lt;/package&amp;gt; 까지가 ROS 패키지 설정 부분이다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;name&amp;gt;&lt;/code&gt;                - 패키지의 이름이다. 패키지를 생성할 때 입력한 패키지의 이름이 사용된다. 다른 옵션도 마찬가지지만 이는 사용자가 원할 때 언제든지 바꿀 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;version&amp;gt;&lt;/code&gt;             - 패키지의 버전이다. 역시 자유롭게 변경 가능하다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;description&amp;gt;&lt;/code&gt;         - 패키지의 간단한 설명을 기술 할 수 있다. 보통 2~3 무장으로 기술하고 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;maintainer&amp;gt;&lt;/code&gt;          - 패키지의 관리자의 이름과 메일 주소를 작성한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;license&amp;gt;&lt;/code&gt;             - 라이선스를 작성한다. BSD, MIT, Apache, GPLv3, LGPLv3 등을 기재하면 된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;url&amp;gt;&lt;/code&gt;                 - 패키지를 설명하는 웹 페이지 또는 버그 관리, 저장소 등의 주소를 기재한다. 이 종류에 따라 type에 website, bugtracker, repository를 대입하면 된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;author&amp;gt;&lt;/code&gt;              - 패키지 개발에 참여한 개발자의 이름과 이메일 주소를 적는다. 복수의 개발자가 참여한 경우에는 바로 다음줄에 &amp;lt;autor&amp;gt; 태그를 이용하여 추가하면 된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;buildtool_depend&amp;gt;&lt;/code&gt;    - 빌드 시스템의 의존성을 기술한다. 지금은 Catkin build system을 이용하고 있으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;catkin&lt;/code&gt;을 입력한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;build_depend&amp;gt;&lt;/code&gt;        - 패키지를 빌드할 때 의존하는 패키지의 이름을 적는다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;run_depend&amp;gt;&lt;/code&gt;          - 패키지를 실행할 때 의존하는 패키지의 이름을 적는다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;test_depend&amp;gt;&lt;/code&gt;         - 패키지를 테스트할 때 의존하는 패키지의 이름을 적는다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;export&amp;gt;&lt;/code&gt;              - ROS에서 명시하지 않는 태그명을 사용할 때 쓰인다. 제일 널리 쓰이는 것은 메타패키지일 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;export&amp;gt;&amp;lt;metapackage/&amp;gt;&amp;lt;/export&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;metapackage&amp;gt;&lt;/code&gt;         - export 태그 안에서 사용하는 공식적인 태그로 현재의 패키지가 메타패키지면 이를 선언한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;직접 커스터마이징 하면 아래와 같이 기술 할 수 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;package&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;my_first_ros_pkg&lt;span class=&quot;nt&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;0.0.1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;description&amp;gt;&lt;/span&gt;The my_first_ros_pkg package&lt;span class=&quot;nt&quot;&gt;&amp;lt;/description&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;license&amp;gt;&lt;/span&gt;Apache License 2.0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/license&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;author&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;email=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lsirikh@gmail.com&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Kiho Lee&lt;span class=&quot;nt&quot;&gt;&amp;lt;/author&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;maintainer&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;email=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lsirikh@gmail.com&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Kiho Lee&lt;span class=&quot;nt&quot;&gt;&amp;lt;/maintainer&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;url&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bugtracker&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;url&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;repository&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;url&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;website&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;https://lsirikh.github.io&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;buildtool_depend&amp;gt;&lt;/span&gt;catkin&lt;span class=&quot;nt&quot;&gt;&amp;lt;/buildtool_depend&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;build_depend&amp;gt;&lt;/span&gt;std_msgs&lt;span class=&quot;nt&quot;&gt;&amp;lt;/build_depend&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;build_depend&amp;gt;&lt;/span&gt;roscpp&lt;span class=&quot;nt&quot;&gt;&amp;lt;/build_depend&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;run_depend&amp;gt;&lt;/span&gt;std_msgs&lt;span class=&quot;nt&quot;&gt;&amp;lt;/run_depend&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;run_depend&amp;gt;&lt;/span&gt;roscpp&lt;span class=&quot;nt&quot;&gt;&amp;lt;/run_depend&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;export&amp;gt;&amp;lt;/export&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/package&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;4-빌드-설정-파일cmakeliststxt-수정&quot;&gt;4. 빌드 설정 파일(CMakeLists.txt) 수정&lt;/h2&gt;

&lt;p&gt;ROS의 빌드 시스템인 Catkin은 기본적으로 CMake를 이용하고 있어서 패키지의 폴더의 &lt;code class=&quot;highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;라는 파일에 빌드 환경을 기술하고 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmake_minimum_required(VERSION 2.8.3)
project(my_first_ros_pkg)

## Compile as C++11, supported in ROS Kinetic and newer
# add_compile_options(-std=c++11)

## Find catkin macros and libraries
## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz)
## is used, also find other catkin packages
find_package(catkin REQUIRED COMPONENTS
  roscpp
  std_msgs
)

## System dependencies are found with CMake's conventions
# find_package(Boost REQUIRED COMPONENTS system)


## Uncomment this if the package has a setup.py. This macro ensures
## modules and global scripts declared therein get installed
## See http://ros.org/doc/api/catkin/html/user_guide/setup_dot_py.html
# catkin_python_setup()

################################################
## Declare ROS messages, services and actions ##
################################################

## To declare and build messages, services or actions from within this
## package, follow these steps:
## * Let MSG_DEP_SET be the set of packages whose message types you use in
##   your messages/services/actions (e.g. std_msgs, actionlib_msgs, ...).
## * In the file package.xml:
##   * add a build_depend tag for &quot;message_generation&quot;
##   * add a build_depend and a exec_depend tag for each package in MSG_DEP_SET
##   * If MSG_DEP_SET isn't empty the following dependency has been pulled in
##     but can be declared for certainty nonetheless:
##     * add a exec_depend tag for &quot;message_runtime&quot;
## * In this file (CMakeLists.txt):
##   * add &quot;message_generation&quot; and every package in MSG_DEP_SET to
##     find_package(catkin REQUIRED COMPONENTS ...)
##   * add &quot;message_runtime&quot; and every package in MSG_DEP_SET to
##     catkin_package(CATKIN_DEPENDS ...)
##   * uncomment the add_*_files sections below as needed
##     and list every .msg/.srv/.action file to be processed
##   * uncomment the generate_messages entry below
##   * add every package in MSG_DEP_SET to generate_messages(DEPENDENCIES ...)

## Generate messages in the 'msg' folder
# add_message_files(
#   FILES
#   Message1.msg
#   Message2.msg
# )

## Generate services in the 'srv' folder
# add_service_files(
#   FILES
#   Service1.srv
#   Service2.srv
# )

## Generate actions in the 'action' folder
# add_action_files(
#   FILES
#   Action1.action
#   Action2.action
# )

## Generate added messages and services with any dependencies listed here
# generate_messages(
#   DEPENDENCIES
#   std_msgs
# )

################################################
## Declare ROS dynamic reconfigure parameters ##
################################################

## To declare and build dynamic reconfigure parameters within this
## package, follow these steps:
## * In the file package.xml:
##   * add a build_depend and a exec_depend tag for &quot;dynamic_reconfigure&quot;
## * In this file (CMakeLists.txt):
##   * add &quot;dynamic_reconfigure&quot; to
##     find_package(catkin REQUIRED COMPONENTS ...)
##   * uncomment the &quot;generate_dynamic_reconfigure_options&quot; section below
##     and list every .cfg file to be processed

## Generate dynamic reconfigure parameters in the 'cfg' folder
# generate_dynamic_reconfigure_options(
#   cfg/DynReconf1.cfg
#   cfg/DynReconf2.cfg
# )

###################################
## catkin specific configuration ##
###################################
## The catkin_package macro generates cmake config files for your package
## Declare things to be passed to dependent projects
## INCLUDE_DIRS: uncomment this if your package contains header files
## LIBRARIES: libraries you create in this project that dependent projects also need
## CATKIN_DEPENDS: catkin_packages dependent projects also need
## DEPENDS: system dependencies of this project that dependent projects also need
catkin_package(
#  INCLUDE_DIRS include
#  LIBRARIES my_first_ros_pkg
#  CATKIN_DEPENDS roscpp std_msgs
#  DEPENDS system_lib
)

###########
## Build ##
###########

## Specify additional locations of header files
## Your package locations should be listed before other locations
include_directories(
# include
  ${catkin_INCLUDE_DIRS}
)

## Declare a C++ library
# add_library(${PROJECT_NAME}
#   src/${PROJECT_NAME}/my_first_ros_pkg.cpp
# )

## Add cmake target dependencies of the library
## as an example, code may need to be generated before libraries
## either from message generation or dynamic reconfigure
# add_dependencies(${PROJECT_NAME} ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})

## Declare a C++ executable
## With catkin_make all packages are built within a single CMake context
## The recommended prefix ensures that target names across packages don't collide
# add_executable(${PROJECT_NAME}_node src/my_first_ros_pkg_node.cpp)

## Rename C++ executable without prefix
## The above recommended prefix causes long target names, the following renames the
## target back to the shorter version for ease of user use
## e.g. &quot;rosrun someones_pkg node&quot; instead of &quot;rosrun someones_pkg someones_pkg_node&quot;
# set_target_properties(${PROJECT_NAME}_node PROPERTIES OUTPUT_NAME node PREFIX &quot;&quot;)

## Add cmake target dependencies of the executable
## same as for the library above
# add_dependencies(${PROJECT_NAME}_node ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})

## Specify libraries to link a library or executable target against
# target_link_libraries(${PROJECT_NAME}_node
#   ${catkin_LIBRARIES}
# )

#############
## Install ##
#############

# all install targets should use catkin DESTINATION variables
# See http://ros.org/doc/api/catkin/html/adv_user_guide/variables.html

## Mark executable scripts (Python etc.) for installation
## in contrast to setup.py, you can choose the destination
# install(PROGRAMS
#   scripts/my_python_script
#   DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
# )

## Mark executables for installation
## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_executables.html
# install(TARGETS ${PROJECT_NAME}_node
#   RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
# )

## Mark libraries for installation
## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_libraries.html
# install(TARGETS ${PROJECT_NAME}
#   ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
#   LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
#   RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION}
# )

## Mark cpp header files for installation
# install(DIRECTORY include/${PROJECT_NAME}/
#   DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
#   FILES_MATCHING PATTERN &quot;*.h&quot;
#   PATTERN &quot;.svn&quot; EXCLUDE
# )

## Mark other files for installation (e.g. launch and bag files, etc.)
# install(FILES
#   # myfile1
#   # myfile2
#   DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
# )

#############
## Testing ##
#############

## Add gtest based cpp test target and link libraries
# catkin_add_gtest(${PROJECT_NAME}-test test/test_my_first_ros_pkg.cpp)
# if(TARGET ${PROJECT_NAME}-test)
#   target_link_libraries(${PROJECT_NAME}-test ${PROJECT_NAME})
# endif()

## Add folders to be run by python nosetests
# catkin_add_nosetests(test)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이제 하나씩 분석을 해보도록 하자.&lt;/p&gt;

&lt;p&gt;출처:[ROS_Robot_Programming_EN]&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="ROS" /><category term="빌드시스템" /><summary type="html">1. 들어가며</summary></entry><entry><title type="html">10.ROS 좌표변환(TF-Transform)</title><link href="http://localhost:4000/categories/ros/ROS-10-TF.html" rel="alternate" type="text/html" title="10.ROS 좌표변환(TF-Transform)" /><published>2019-12-16T00:00:00+00:00</published><updated>2019-12-16T00:00:00+00:00</updated><id>http://localhost:4000/categories/ros/ROS-10-TF</id><content type="html" xml:base="http://localhost:4000/categories/ros/ROS-10-TF.html">&lt;h2 id=&quot;1-좌표-변환tf란&quot;&gt;1. 좌표 변환(TF)란?&lt;/h2&gt;

&lt;p&gt;로봇의 팔 자세를 설명 할 때 각 관절의 상대 좌표 변환으로 설명 할 수 있다.
로봇이 걷고있을 때, 로봇 손의 좌표는 각각의 상관 된 관절의 상대 좌표 변환에 따라 움직인다.
로봇 프로그래밍에서 각 로봇의 관절(또는 회전축이 있는 바퀴)의 위치는 매우 중요한 요소이며, ROS에서는 TF (변형)로 표시된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_tf.png&quot; title=&quot;좌표변환&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;ROS에서 좌표변환 TF는 장애물과 물체뿐만 아니라 로봇의 구성 요소를 설명 할 때 가장 유용한 개념 중 하나이다.&lt;/p&gt;

&lt;h2 id=&quot;2-좌표-변환-구성&quot;&gt;2. 좌표 변환 구성&lt;/h2&gt;

&lt;p&gt;이들은 자세(pose)라 하여 위치(position)와 방향(orientation)으로 기술할 수 있다. 여기서, 위치는 x, y, z과 같이 3개의 벡터로 설명하고 방향은 사원수라 일컫는 쿼티니언(quaternion) 형태의 x, y, z, w를 이용한다.&lt;/p&gt;

&lt;p&gt;TF는 메시지와 같이 다음과 같은 형태를 취하고 있다.&lt;/p&gt;

&lt;p&gt;변환된 시간을 기록할 목적으로 Header를 사용하며, 하위 좌표를 명시하기 위하여 child_frame_id라는 이름의 메시지를 사용한다. 그리고 상대 좌표 변환값을 알려주기 위하여&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;transform.translation.x&lt;/li&gt;
  &lt;li&gt;transform.translation.y&lt;/li&gt;
  &lt;li&gt;transform.translation.z&lt;/li&gt;
  &lt;li&gt;transform.rotation.x&lt;/li&gt;
  &lt;li&gt;transform.rotation.y&lt;/li&gt;
  &lt;li&gt;transform.rotation.z&lt;/li&gt;
  &lt;li&gt;transform.rotation.w&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Header header
string child_frame_id
Transform transform
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;추후에 좀 더 다양한 프로젝트를 구성해서 다뤄보도록 하자.&lt;/p&gt;

&lt;p&gt;출처:[ROS_Robot_Programming_EN]&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="ROS" /><category term="좌표변환" /><category term="TF" /><category term="transform" /><summary type="html">1. 좌표 변환(TF)란?</summary></entry><entry><title type="html">11.ROS 추가적 특징(라이브러리, 이기종 디바이스 통신)</title><link href="http://localhost:4000/categories/ros/ROS-11-additional-feature.html" rel="alternate" type="text/html" title="11.ROS 추가적 특징(라이브러리, 이기종 디바이스 통신)" /><published>2019-12-16T00:00:00+00:00</published><updated>2019-12-16T00:00:00+00:00</updated><id>http://localhost:4000/categories/ros/ROS-11-additional-feature</id><content type="html" xml:base="http://localhost:4000/categories/ros/ROS-11-additional-feature.html">&lt;h2 id=&quot;1-클라이언트-라이브러리&quot;&gt;1. 클라이언트 라이브러리&lt;/h2&gt;

&lt;p&gt;ROS는 다양한 언어들을 활용하여 목적에 맞게 개발할 수 있도록 지원하고 있다.&lt;/p&gt;

&lt;p&gt;노드는 각각의 언어로 작성이 가능하고 노드 간의 메시지 통신을 통해 정보를 교환하는 방법을 이용하고 있다. 이처럼 각각의 언어로 작성 가능하게 해주는 소프트웨어 모듈이 클라이언트 라이브러리(client library)이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C++ - roscpp&lt;/li&gt;
  &lt;li&gt;Python - rospy&lt;/li&gt;
  &lt;li&gt;LISP - roslisp&lt;/li&gt;
  &lt;li&gt;Java - rosjava&lt;/li&gt;
  &lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 외에도 많은 언어에 대한 클라이언트 라이브러리를 지원하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;2-이기종-디바이스-통신&quot;&gt;2. 이기종 디바이스 통신&lt;/h2&gt;

&lt;p&gt;ROS가 설치되어 사용하는 운영체제의 종류와도 상관없고, 사용하는 프로그래밍 언어도 상관없이 ROS가 설치되어 각 노드가 개발되어있다면 각 노드들 간의 통신은 매우 쉽게 이용 가능하다.&lt;/p&gt;

&lt;p&gt;예를 들어 Linux 배포판 인 Ubuntu가 로봇에 설치되어 있어도 MacOS에서 로봇의 상태를 모니터링 할 수 있다. 동시에 사용자는 Android 기반 앱에서 로봇에게 명령을 내릴 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_cross_platform.png&quot; title=&quot;이기종 디바이스 통신&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;출처:[ROS_Robot_Programming_EN]&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="ROS" /><category term="라이브러리" /><category term="이기종디바이스통신" /><summary type="html">1. 클라이언트 라이브러리</summary></entry><entry><title type="html">07.ROS 메시지 더 알아보기</title><link href="http://localhost:4000/categories/ros/ROS-07-message.html" rel="alternate" type="text/html" title="07.ROS 메시지 더 알아보기" /><published>2019-12-13T00:00:00+00:00</published><updated>2019-12-13T00:00:00+00:00</updated><id>http://localhost:4000/categories/ros/ROS-07-message</id><content type="html" xml:base="http://localhost:4000/categories/ros/ROS-07-message.html">&lt;h2 id=&quot;1-메시지란&quot;&gt;1. 메시지란?&lt;/h2&gt;

&lt;p&gt;메시지는 노드 간 데이터 교환에 사용되는 데이터 모음이다. 토픽, 서비스 및 액션에는 메시지를 사용하여 통신한다.&lt;/p&gt;

&lt;p&gt;메시지에는 정수, 부동 소수점, 부울과 같은 기본 데이터 유형과 ‘float32 [] ranges’, ‘Point32 [10] points’와 같은 메시지 배열이 포함될 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 메시지는 아래와 같이 필드 유형 및 필드 이름으로 설명 할 수 있다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;fieldtype1 fieldname1
fieldtype2 fieldname2
fieldtype3 fieldname3
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;필드타입에는 아래 표와 같이 ROS 자료형을 기입하게 되고, 필드네임에는 데이터를 의미하는 이름을 적어주게 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;int32 x
int32 y
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ROS Data Type&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Serialization&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;C++ Data Type&lt;/th&gt;
      &lt;th&gt;Python Data Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;bool&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;unsigned 8-bit int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;uint8_t&lt;/td&gt;
      &lt;td&gt;bool&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;int8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;signed 8-bit int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int8_t&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;uint8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;unsigned 8-bit int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;uint8_t&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;int16&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;signed 16-bit int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int16_t&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;uint16&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;unsigned 16-bit int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;uint16_t&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;int32&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;signed 32-bit int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int32_t&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;uint32&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;unsigned 32-bit int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;uint32_t&lt;/td&gt;
      &lt;td&gt;int&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;int64&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;signed 64-bit int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int64_t&lt;/td&gt;
      &lt;td&gt;long&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;uint64&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;unsigned 64-bit int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;uint64_t&lt;/td&gt;
      &lt;td&gt;long&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;float32&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;32-bit IEEE float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float&lt;/td&gt;
      &lt;td&gt;float&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;float64&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;64-bit IEEE float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double&lt;/td&gt;
      &lt;td&gt;float&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;string&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ascii string&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;std::string&lt;/td&gt;
      &lt;td&gt;str&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;time&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;secs/nsecs unsigned 32-bit ints&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ros::time&lt;/td&gt;
      &lt;td&gt;rospy.Time&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;duration&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;secs/nsecs signed 32-bit ints&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ros::Duration&lt;/td&gt;
      &lt;td&gt;rospy.Duration&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;small&gt;[표7-1] ROS의 기본 메시지 자료형&lt;/small&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ROS Data Type&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Serialization&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;C++ Data Type&lt;/th&gt;
      &lt;th&gt;Python Data Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;fixed-length&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;no extra serialization&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boost::array, std::vector&lt;/td&gt;
      &lt;td&gt;tuple&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;variable-length&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;uint32 length prefix&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;std::vector&lt;/td&gt;
      &lt;td&gt;tuple&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;uint8[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;uint32 length prefix&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;std::vector&lt;/td&gt;
      &lt;td&gt;bytes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bool[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;uint32 length prefix&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;std::vector&amp;lt;uint8_t&amp;gt;&lt;/td&gt;
      &lt;td&gt;list of bool&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;small&gt;[표7-2] ROS의 메시지 자료형에서 배열처럼 사용하는 방법&lt;small&gt;&lt;/small&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;ROS에서 일반적으로 사용되는 헤더 (std_msgs / Header)도 메시지로 사용할 수 있다. std_msgs의 Header.msg 파일에는 시퀀스 ID, 타임 스탬프 및 프레임 ID가 포함되어 있으며 이를 사용하여 메시지를 조사하거나 시간을 측정한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;std_msgs/Header.msg&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# Sequence ID: Messages are sequentially incremented by 1.&lt;/span&gt;
uint32 &lt;span class=&quot;nb&quot;&gt;seq&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Timestamp: Has two child attributes, the stamp.sec for second and the stamp.nsec for nanosecond.&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;stamp
&lt;span class=&quot;c&quot;&gt;# Stores the Frame ID&lt;/span&gt;
string frame_id
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;다음은 실제로 ROS 프로그램에서 메시지를 사용하는 방법이다.
turtlesim 패키지의 ‘teleop_turtle_key’ 노드의 경우 변환 속도 (미터/초) 및 회전 속도 (라디안/초)가 다음과 같이 turtlesim 노드에 메시지로 전송된다. 키보드에서 입력 한 방향키 (←, →, ↑, ↓)로 TurtleBot는 수신 된 속도 값을 사용하여 화면에서 움직인다. 
현재 사용되는 메시지는‘geometry_msgs’의‘twist’ 메시지이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Vector3 linear
Vector3 angular
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위의 메시지 구조에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;linear&lt;/code&gt;및 &lt;code class=&quot;highlighter-rouge&quot;&gt;radian&lt;/code&gt;값은 Vector3 유형으로 선언된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;float64 x
float64 y
float64 z
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;다시 말해 &lt;code class=&quot;highlighter-rouge&quot;&gt;teleop_turtle_key&lt;/code&gt;노드에서 퍼블리시 된 6개의 토픽은 linear.x, linear.y, linear.z, angular.x, angular.y 및 angular.z 이다. 모두는 ROS에 설명 된 기본 데이터 유형 중 하나 인 float64 유형이다. 이러한 데이터를 사용하여 키보드의 화살표 키를 이동 속도 (미터/초) 및 회전 속도 (라디안/초) 메시지로 변환 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;2-msg-파일&quot;&gt;2. msg 파일&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;msg&lt;/code&gt; 파일은 주제가 사용하는 메시지 파일이며 파일 확장자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;* .msg&lt;/code&gt;입니다. 위에서 설명한 &lt;code class=&quot;highlighter-rouge&quot;&gt;geometry_msgs&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Twist&lt;/code&gt; 메시지는 메시지의 예다. 이러한 msg 파일은 필드 유형과 필드 이름으로 구성된다.&lt;/p&gt;

&lt;h2 id=&quot;3-srv-파일&quot;&gt;3. srv 파일&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;srv&lt;/code&gt;파일은 파일 확장자가 &lt;code class=&quot;highlighter-rouge&quot;&gt;* .srv&lt;/code&gt;인 서비스에서 사용하는 메시지 파일이다.
예를 들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;sensor_msgs&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;SetCameraInfo&lt;/code&gt; 메시지는 일반적인 srv 파일이다. msg 파일과의 주요 차이점은 일련의 세 개의 하이픈 (&lt;strong&gt;---&lt;/strong&gt;)이 구분 기호로 사용된다는 것이다. 상위 메시지는 서비스 요청 메시지이고 하위 메시지는 서비스 응답 메시지이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sensor_msgs/CameraInfo camera_info
&lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;
bool success
string status_message
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;4-action-파일&quot;&gt;4. action 파일&lt;/h2&gt;

&lt;p&gt;액션 메시지 파일은 액션에서 사용하는 메시지 파일이며 파일 확장자는 ‘* .action’이다.
msg 및 srv와 달리 비교적 드문 메시지 파일이므로 메시지 파일의 일반적인 예는 없지만 다음 예와 같이 사용할 수 있다. 
msg 및 srv 파일과의 주요 차이점은 일련의 3 개의 하이픈 (&lt;strong&gt;---&lt;/strong&gt;)이 구분 기호로 두 위치에서 사용된다는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;첫 번째는 목표(goal) 메시지&lt;/li&gt;
  &lt;li&gt;두 번째는 결과(result) 메시지,&lt;/li&gt;
  &lt;li&gt;세 번째는 &lt;strong&gt;피드백(feedback)&lt;/strong&gt; 메시지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;액션 파일의 가장 큰 차이점은 피드백 메시지 기능이다. 액션 파일의 목표 메시지 및 결과 메시지는 위에서 언급 한 srv 파일의 요청 및 응답 메시지와 비교 될 수 있지만 지정된 프로세스가 수행되는 동안 액션 파일의 추가 피드백 메시지가 피드백을 보내는 데 사용된다.
다음 예에서 설명하는 것처럼 로봇의 시작 위치 ‘start_pose’와 목표 ‘goal_pose’가 요청 값으로 전송되면 로봇은 수신 된 목표 위치로 이동하여 ‘result_pose’를 반환한다. 로봇이 목표 위치로 이동하는 동안 ‘percent_complete’ 메시지는 주기적으로 도달한 목표 지점의 백분율 형식으로 진행률을 나타내는 피드백 값을 전송한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;geometry_msgs/PoseStamped start_pose
geometry_msgs/PoseStamped goal_pose
&lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;
geometry_msgs/PoseStamped result_pose
&lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;
float32 percent_complete
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;출처:[ROS_Robot_Programming_EN]&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="ROS" /><category term="메시지" /><summary type="html">1. 메시지란?</summary></entry><entry><title type="html">08.ROS 네임(Name)</title><link href="http://localhost:4000/categories/ros/ROS-08-name.html" rel="alternate" type="text/html" title="08.ROS 네임(Name)" /><published>2019-12-13T00:00:00+00:00</published><updated>2019-12-13T00:00:00+00:00</updated><id>http://localhost:4000/categories/ros/ROS-08-name</id><content type="html" xml:base="http://localhost:4000/categories/ros/ROS-08-name.html">&lt;h2 id=&quot;1-개념&quot;&gt;1. 개념&lt;/h2&gt;

&lt;p&gt;ROS에는 기본 개념으로 &lt;strong&gt;그래프&lt;/strong&gt;라는 추상 데이터 유형이 있다. 이 그래프는 각 노드 간의 연결 관계와 화살표로 보내고받는 메시지 (데이터)의 관계를 보여준다. 이를 위해 ROS의 노드, 토픽 및 서비스에 사용되는 메시지 및 매개 변수는 모두 고유 한 이름을 갖습니다.&lt;/p&gt;

&lt;h2 id=&quot;2-종류&quot;&gt;2. 종류&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;글로벌(global)&lt;/li&gt;
  &lt;li&gt;프라이빗(private)&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 		
&lt;span class=&quot;c1&quot;&gt;// Node Main Function&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ros&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;node1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 		 &lt;span class=&quot;c1&quot;&gt;// Node Name Initialization&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ros&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NodeHandle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 			 &lt;span class=&quot;c1&quot;&gt;// Node Handle Declaration&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Publisher Declaration, Topic Name = bar&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ros&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node1_pub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;advertise&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std_msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 예에서 노드 이름은 &lt;code class=&quot;highlighter-rouge&quot;&gt;/node1&lt;/code&gt;이다. 퍼블리셔가 기호없이 &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;로 선언 된 경우 주제의 상대 이름은 &lt;code class=&quot;highlighter-rouge&quot;&gt;/bar&lt;/code&gt;이다. 슬래시 (&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;) 문자를 사용하여 전역으로 선언하더라도 토픽 이름은 여전히 &lt;code class=&quot;highlighter-rouge&quot;&gt;/bar&lt;/code&gt;이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;글로벌&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;ros&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node1_pub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;advertise&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std_msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/bar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그러나 프라이빗(&lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt;)으로 선언한 경우 토픽 네임이 &lt;code class=&quot;highlighter-rouge&quot;&gt;/node1/var&lt;/code&gt;가 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프라이빗&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;ros&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node1_pub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;advertise&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std_msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;~bar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/wg&lt;/code&gt;는 네임 스페이스가 변경된 것을 의미한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Node&lt;/th&gt;
      &lt;th&gt;Relative(Default)&lt;/th&gt;
      &lt;th&gt;Global&lt;/th&gt;
      &lt;th&gt;Private&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;/node1&lt;/td&gt;
      &lt;td&gt;bar → /bar&lt;/td&gt;
      &lt;td&gt;/bar → /bar&lt;/td&gt;
      &lt;td&gt;~bar → /node1/bar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/wg/node2&lt;/td&gt;
      &lt;td&gt;bar → /wg/bar&lt;/td&gt;
      &lt;td&gt;/bar → /bar&lt;/td&gt;
      &lt;td&gt;~bar → /wg/node2/bar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/wg/node3&lt;/td&gt;
      &lt;td&gt;foo/bar → /wg/foo/bar&lt;/td&gt;
      &lt;td&gt;/foo/bar → /foo/bar&lt;/td&gt;
      &lt;td&gt;~foo/bar → /wg/node3/foo/bar&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;small&gt;[표8-1]네이밍 규칭&lt;/small&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-네이밍-활용&quot;&gt;3. 네이밍 활용&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;두 대의 카메라를 어떻게 실행할 수 있을까?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;ROS에 고유 한 이름이 있어야하기 때문에 관련 노드를 두 번 실행하면 이전에 실행 된 노드가 종료된다. 그러나 두 대의 카메라를 실행하기 위해 별도의 프로그램을 실행하거나 소스 코드를 변경하지 않아도된다. 네임 스페이스를 사용하거나 리매핑을 활용하여 노드를 실행할 때 간단히 노드 이름을 변경하면된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이해를 돕기 위해 가상 &lt;code class=&quot;highlighter-rouge&quot;&gt;camera_package&lt;/code&gt;가 있다고 가정해보자. &lt;code class=&quot;highlighter-rouge&quot;&gt;camera_package&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;camera_node&lt;/code&gt;가 실행될 때 카메라 노드가 실행되었다고 가정하면, 이를 실행하는 방법은 다음과 같을 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$rosrun camera_package camera_node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;camera_node&lt;/code&gt;가 image 토픽을 통해 카메라의 이미지 데이터를 전송하면 다음과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;rqt_image_view&lt;/code&gt;를 사용하여이 image 토픽을 수신 할 수 있다(가정).&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$rosrun rqt_image_view rqt_image_view
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이제 리매핑하여 이러한 노드의 토픽 값을 수정해보자. 다음 명령은 토픽 이름을 &lt;code class=&quot;highlighter-rouge&quot;&gt;/front/image&lt;/code&gt;로 변경한다. 아래 명령에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;image&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;camera_node&lt;/code&gt;의 토픽 이름이고 아래 예는 실행 명령에서 옵션을 설정하여 토픽 이름을 변경하는 방법을 보여준다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rosrun camera_package camera_node image:=front/image
$ rosrun rqt_image_view rqt_image_view image:=front/image
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예를 들어, front, left 및 right와 같은 세 개의 카메라가있는 경우 여러 노드가 동일한 이름으로 실행될 때 이름이 충돌하여 이전에 실행 된 노드가 종료된다. 따라서, 이름이 같은 노드는 다음과 같은 방식으로 실행할 수 있다. 아래에서 이름 옵션 뒤에 연속 밑줄 (&lt;em&gt;_)이 온다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;__ns&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;__name&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;__log&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;__ip&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;__hostname&lt;/code&gt; 및 &lt;code class=&quot;highlighter-rouge&quot;&gt;__master&lt;/code&gt;와 같은 옵션은 노드를 실행할 때 사용되는 특수 옵션이다. 또한, 단일 밑줄 (&lt;/em&gt;)은 프라이빗으로 사용될 경우 토픽 이름 앞에 배치된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rosrun camera_package camera_node __name:=front _device:=/dev/video0
$ rosrun camera_package camera_node __name:=left _device:=/dev/video1
$ rosrun camera_package camera_node __name:=right _device:=/dev/video2
$ rosrun rqt_image_view rqt_image_view
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하나의 네임스페이스(namespace)로 묶어주고 싶다면 아래와 같이 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rosrun camera_package camera_node __ns:=back
$ rosrun rqt_imgae_view rqt_imgae_view __ns:=back
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;출처:[ROS_Robot_Programming_EN]&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="ROS" /><category term="네임" /><category term="name" /><summary type="html">1. 개념</summary></entry><entry><title type="html">09.ROS 웹캠 실행 해보기</title><link href="http://localhost:4000/categories/ros/ROS-09-camera-operation.html" rel="alternate" type="text/html" title="09.ROS 웹캠 실행 해보기" /><published>2019-12-13T00:00:00+00:00</published><updated>2019-12-13T00:00:00+00:00</updated><id>http://localhost:4000/categories/ros/ROS-09-camera-operation</id><content type="html" xml:base="http://localhost:4000/categories/ros/ROS-09-camera-operation.html">&lt;h2 id=&quot;1-카메라-확인&quot;&gt;1. 카메라 확인&lt;/h2&gt;

&lt;p&gt;일단 삼성 USB camera를 USB 포트에 연결 하고, 아래의 명령어를 입력하면 다음과 같이 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/samsung_web_cam.png&quot; title=&quot;삼성 웹캠 화면&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ls -ltr /dev/video*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/ros/camera_device.png&quot; title=&quot;USB 카메라 장치&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-패키지-설치&quot;&gt;2. 패키지 설치&lt;/h2&gt;

&lt;p&gt;이제부터 활용할 ROS 패키지는 uvc_camera 라는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/uvc_camera_wiki.png&quot; title=&quot;uvc_camera package&quot; /&gt;&lt;br /&gt;
출처:&lt;a href=&quot;http://wiki.ros.org/uvc_camera&quot;&gt;uvc_camera&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;cs를 하여 catkin_ws/src로 이동하자.(환경설정에서 다루었던 내용)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cs
~/catkin_ws/src$ git clone https://github.com/ros-drivers/camera_umd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;git으로 데이터 패키지를 다운받고 받은 폴더를 ls를 이용하여 확인해보자&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/catkin_ws/src$ ls
camera_umd      my_first_ros_pkg  turtlebot3_msgs
CMakeLists.txt  turtlebot3        turtlebot3_simulations
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;3-패키지-빌드&quot;&gt;3. 패키지 빌드&lt;/h2&gt;

&lt;p&gt;이제 패키지를 빌드해보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/catkin_ws/src$ cm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_uvc_install_fail.png&quot; title=&quot;uvc_camera package 설치실패&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;젠장 에러뜬다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;의존성 문제로 해당 문제를 해결하기 위해서는 아래의 커멘드를 입력해야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_uvc_install_success.png&quot; title=&quot;uvc_camera package 설치성공&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/catkin_ws$ rospack profile
Full tree crawl took 0.045761 seconds.
Directories marked with (*) contain no manifest.  You may
want to delete these directories.
To get just of list of directories without manifests,
re-run the profile with --zombie-only
-------------------------------------------------------------
0.037673   /opt/ros/kinetic/share
0.005741   /home/memaker/catkin_ws/src
0.002084   /home/memaker/catkin_ws/src/turtlebot3
0.001374   /home/memaker/catkin_ws/src/camera_umd
0.000856   /home/memaker/catkin_ws/src/turtlebot3_simulations
0.000228 * /opt/ros/kinetic/share/OpenCV-3.3.1-dev
0.000049 * /opt/ros/kinetic/share/OpenCV-3.3.1-dev/haarcascades
0.000049 * /opt/ros/kinetic/share/doc
0.000021 * /opt/ros/kinetic/share/OpenCV-3.3.1-dev/lbpcascades
0.000009 * /opt/ros/kinetic/share/doc/liborocos-kdl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4-launch-파일-편집하기&quot;&gt;4. launch 파일 편집하기&lt;/h2&gt;

&lt;p&gt;launch 파일이 저장된 위치로 열심히 이동을 한다.
카메라 스펙에 맞게 몇가지 항목을 변경 할 필요가 있다.(&lt;strong&gt;물론 그냥 실행해도 무관하다고 봄&lt;/strong&gt;)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/catkin_ws$ cd ./src/camera_umd/uvc_camera/launch/
~/catkin_ws/src/camera_umd/uvc_camera/launch$ gedit ./camera_node.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;카메라에 따라 해상도 지원하는 스펙이 다를 수 있다. 확인하고 설정하자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;launch&amp;gt;
  &amp;lt;node pkg=&quot;uvc_camera&quot; type=&quot;uvc_camera_node&quot; name=&quot;uvc_camera&quot; output=&quot;screen&quot;&amp;gt;
    &amp;lt;param name=&quot;width&quot; type=&quot;int&quot; value=&quot;640&quot; /&amp;gt;
    &amp;lt;param name=&quot;height&quot; type=&quot;int&quot; value=&quot;480&quot; /&amp;gt;
    &amp;lt;param name=&quot;fps&quot; type=&quot;int&quot; value=&quot;30&quot; /&amp;gt;
    &amp;lt;param name=&quot;frame&quot; type=&quot;string&quot; value=&quot;wide_stereo&quot; /&amp;gt;

    &amp;lt;param name=&quot;auto_focus&quot; type=&quot;bool&quot; value=&quot;False&quot; /&amp;gt;
    &amp;lt;param name=&quot;focus_absolute&quot; type=&quot;int&quot; value=&quot;0&quot; /&amp;gt;
    &amp;lt;!-- other supported params: auto_exposure, exposure_absolute, brightness, power_line_frequency --&amp;gt;

    &amp;lt;param name=&quot;device&quot; type=&quot;string&quot; value=&quot;/dev/video0&quot; /&amp;gt;
    &amp;lt;param name=&quot;camera_info_url&quot; type=&quot;string&quot; value=&quot;file://$(find uvc_camera)/example.yaml&quot; /&amp;gt;
  &amp;lt;/node&amp;gt;
&amp;lt;/launch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;편집하고 꼭 저장을 하자.&lt;/p&gt;

&lt;h2 id=&quot;5-실행&quot;&gt;5. 실행&lt;/h2&gt;

&lt;p&gt;실행해보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/catkin_ws/src/camera_umd/uvc_camera/launch$ cw
~/catkin_ws$ roslaunch uvc_camera camera_node.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;6-rqt_image_view-실행&quot;&gt;6. rqt_image_view 실행&lt;/h2&gt;

&lt;p&gt;퍼블리셔 노드를 roslaucn로 실행했기 때문에 서브스크라이버로 rqt_image_view를 이용해서 확인해보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/catkin_ws$ rqt_image_view
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/rqt_image_view_uvc_camera.png&quot; title=&quot;uvc_camera 화면&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;색감조절이 필요할 듯하지만, 일단 화면이 나오는 것은 확인할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;7-roscore와-rosrun-활용더-좋은-화면-제공&quot;&gt;7. roscore와 rosrun 활용(더 좋은 화면 제공)&lt;/h2&gt;

&lt;p&gt;기존에 roslaunch를 활용하면 색감이 좀 나간 것 처럼 나오는 효과가 있어서, roscore를 활용해 보았다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ roscore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그리고, 퍼블리셔 노드를 실행해줘야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rosrun uvc_camera uvc_camera_node _device:=/dev/video0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이제 서브스크라이버 역할을 할 rqt_image_view 를 실행해보자&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rqt_image_view
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/ros/rqt_image_uvc_camera2.png&quot; title=&quot;uvc_camera roscore rosrun 실행시&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;당연히 rosrun과 rosluanch 상관없이 몇 가지 옵션을 손 보면 더 좋은 화면과 이미지가 제공될 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;출처:[ROS_Robot_Programming_EN]&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="ROS" /><category term="카메라" /><category term="uvc_camera" /><category term="웹캠" /><summary type="html">1. 카메라 확인</summary></entry><entry><title type="html">06.GIT 파일 트랙킹 중지 및 재시작</title><link href="http://localhost:4000/categories/git/GIT-06-git-tracking-abort.html" rel="alternate" type="text/html" title="06.GIT 파일 트랙킹 중지 및 재시작" /><published>2019-12-12T00:00:00+00:00</published><updated>2019-12-12T00:00:00+00:00</updated><id>http://localhost:4000/categories/git/GIT-06-git-tracking-abort</id><content type="html" xml:base="http://localhost:4000/categories/git/GIT-06-git-tracking-abort.html">&lt;h2 id=&quot;1-들어가며&quot;&gt;1. 들어가며&lt;/h2&gt;

&lt;p&gt;git을 쓰면서 트랙킹되고 있는 파일 즉, git의 인덱스에 등록된 파일을 &lt;strong&gt;.gitignore&lt;/strong&gt;로 등록해도 작동이 안되는 경우가 있다. 사실 gitignore와 다른 개념이기 때문에 이 명령어가 작동 안되는 것이다.&lt;/p&gt;

&lt;p&gt;지금같은 경우는 &lt;code class=&quot;highlighter-rouge&quot;&gt;로컬에 파일은 있지만, 이 파일을 리모트로 올리지 않겠다(리모트는 있으면 삭제됨)&lt;/code&gt;가 아니라, &lt;code class=&quot;highlighter-rouge&quot;&gt;로컬의 파일과 리모트의 파일의 내용을 다르게 유지하고 싶은 경우&lt;/code&gt;에 해당한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 쓰면, 기존에 해당 폴더에 있는 모든 파일과 하위 폴더 내용이 모두 git index에 등록이 된다.&lt;/p&gt;

&lt;p&gt;그래서 우리는 .gitignore라는 파일을 활용하게 되는데, 이미 등록이 된 경우 인덱스에서 빠져나오지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;2-gitignore-만들기-참고&quot;&gt;2. .gitignore 만들기 (참고)&lt;/h2&gt;

&lt;p&gt;이 경우는 사실 로컬 디렉토리에는 존재하는 파일이지만, 리모트(github)에는 올리고 싶지 않은 *.log파일이나 기타 파일들에 해당할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로컬 &lt;strong&gt;.gitignore&lt;/strong&gt;를 만듭니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;저장소에 &lt;strong&gt;.gitignore&lt;/strong&gt; 라는 파일을 생성하면 Git은 커밋하기 전에 파일을 사용하여 무시할 파일과 디렉토리를 결정한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.gitignore&lt;/strong&gt;의 파일은 저장소로 &lt;strong&gt;git add&lt;/strong&gt;를 수행할 때, 추적하지 않고, &lt;strong&gt;git commit&lt;/strong&gt;을 통해 인덱싱 되지 않고, &lt;strong&gt;git push&lt;/strong&gt;를 통해 리모트 리포지토리에도 저장되지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;1-터미널에서-git-저장소의-위치로-이동&quot;&gt;(1) 터미널에서 Git 저장소의 위치로 이동&lt;/h3&gt;
&lt;h3 id=&quot;2-gitignore-파일-생성&quot;&gt;(2) .gitignore 파일 생성&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ touch .gitignore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파일이 이미 체크인되어 있고 무시하려는 경우 나중에 규칙을 추가해도 Git 은 파일을 무시하지 않는다. 이 경우 터미널에서 다음 명령을 실행하여 파일을 먼저 추적 해제해야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rm --cached FILENAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 하면 git index에서 파일이 삭제되고, 디스크 상에 파일은 존재한다. 이후  commit과 push를 하면, 리모트에 존재하는 파일도 사라지게 된다.&lt;/p&gt;

&lt;p&gt;[출처]&lt;a href=&quot;https://help.github.com/en/github/using-git/ignoring-files&quot;&gt;GitHub Help&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-리모트-파일과-로컬-파일-다르게-유지하기&quot;&gt;3. 리모트 파일과 로컬 파일 다르게 유지하기&lt;/h2&gt;

&lt;p&gt;작업을 하다보면, 서버로 올라가서 작동하는 파일이 개발자가 로컬에서 테스트하는 환경과 다르게 유지해야 되는 경우가 비일비재하다.
그럴 경우, 로컬에서 파일을 테스트하고 올리기 전에 세팅파일을 변경해서 커밋하는 번거로움을 중단하고, git index에서 추적을 중단시켜 놓는 방법이 있다. 즉, git의 index에서 파일 트래킹을 중지 시키는 것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git update-index --assume-unchanged &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 다시 트랙킹이 필요할 경우 아래 명령어로 트래킹 유지로 복구 시킬 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git update-index --no-assume-unchanged &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 폴더 자체를 트래킹 중지를 하고자 하면,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git ls-files -z .settings | xargs -0 git update-index --assume-unchanged
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[출처]&lt;a href=&quot;https://seotory.tistory.com/5&quot;&gt;seotory&lt;/a&gt;&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="GIT" /><category term="트래킹중지" /><category term="트래킹재시작" /><summary type="html">1. 들어가며</summary></entry><entry><title type="html">06.ROS 메시지 통신의 흐름</title><link href="http://localhost:4000/categories/ros/ROS-06-communication-process.html" rel="alternate" type="text/html" title="06.ROS 메시지 통신의 흐름" /><published>2019-12-12T00:00:00+00:00</published><updated>2019-12-12T00:00:00+00:00</updated><id>http://localhost:4000/categories/ros/ROS-06-communication-process</id><content type="html" xml:base="http://localhost:4000/categories/ros/ROS-06-communication-process.html">&lt;h2 id=&quot;1-들어가며&quot;&gt;1. 들어가며&lt;/h2&gt;

&lt;p&gt;메시지 통신의 흐름에 앞서 통신 방식을 간략하게 집고 넘어가면 아래 표와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_communication3.jpeg&quot; title=&quot;ROS 메시지통신&quot; /&gt;
출처:&lt;a href=&quot;https://robertchoi.gitbook.io/ros/untitled-2&quot;&gt;ROS 하루에 입문하기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/Selection_004.png&quot; title=&quot;메시지통신 종류와 특징&quot; /&gt;
출처:[ROS_Robot_Programming_EN]&lt;/p&gt;

&lt;h2 id=&quot;2-토픽-메시지-통신의-흐름&quot;&gt;2. 토픽 메시지 통신의 흐름&lt;/h2&gt;

&lt;p&gt;마스터는 노드의 정보를 관리하고 각 노드는 필요에 따라 다른 노드를 연결하고 통신한다.&lt;/p&gt;

&lt;h3 id=&quot;1-마스터-실행&quot;&gt;(1) 마스터 실행&lt;/h3&gt;

&lt;p&gt;노드 간 메시지 통신에서 연결 정보를 관리하는 마스터는 ROS를 사용하기 위해 먼저 실행해야하는 필수 요소이다. ROS 마스터는 &lt;strong&gt;roscore&lt;/strong&gt; 명령을 사용하여 실행되며 &lt;strong&gt;XMLRPC&lt;/strong&gt;로 서버를 실행한다. 마스터는 노드 네임, 토픽, 서비스, 조치, 메시지 유형, URI 주소 및 노드 간 연결을위한 포트를 등록하고 요청시 다른 노드로 정보를 중계한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ roscore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_master.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;ROS Master(core) 실행&quot; /&gt;&lt;br /&gt;
출처:[ROS_Robot_Programming_EN]&lt;/p&gt;

&lt;h3 id=&quot;2-서브스크라이버-노드-실행&quot;&gt;(2) 서브스크라이버 노드 실행&lt;/h3&gt;

&lt;p&gt;서브스크라이버 노드는 &lt;strong&gt;rosrun&lt;/strong&gt; 또는 &lt;strong&gt;roslaunch&lt;/strong&gt; 명령으로 실행된다. 서브스크라이버 노드는 노드 이름, 토픽 이름, 메시지 유형, URI 주소 및 포트를 마스터가 실행되는 대로 등록한다. 마스터와 노드는 &lt;strong&gt;XMLRPC&lt;/strong&gt;를 사용하여 통신을 하게된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rosrun PACKAGE_NAME NODE_NAME
$ roslaunch PACKAGE_NAME LAUNCH_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_subscriber_run.png&quot; title=&quot;서브스크라이버 실행&quot; /&gt;&lt;br /&gt;
출처:[ROS_Robot_Programming_EN]&lt;/p&gt;

&lt;h3 id=&quot;3-퍼블리셔-노드-실행&quot;&gt;(3) 퍼블리셔 노드 실행&lt;/h3&gt;

&lt;p&gt;퍼블리셔 노드는 서브스크라이버 노드와 같은 방식(&lt;strong&gt;rosrun&lt;/strong&gt; 또는 &lt;strong&gt;roslaunch&lt;/strong&gt; 명령)으로 실행된다. 퍼블리셔 노드도 노드 이름, 토픽 이름, 메시지 유형, URI 주소 및 포트를 마스터가 실행되는 대로 등록한다. 마스터와 노드는 &lt;strong&gt;XMLRPC&lt;/strong&gt;를 사용하여 통신을 하게된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_publisher_run.png&quot; title=&quot;퍼블리셔 노드 실행&quot; /&gt;&lt;br /&gt;
출처:[ROS_Robot_Programming_EN]&lt;/p&gt;

&lt;h3 id=&quot;4-퍼블리셔-정보-제공&quot;&gt;(4) 퍼블리셔 정보 제공&lt;/h3&gt;

&lt;p&gt;마스터는 퍼블리셔의 이름, 토픽 이름, 메시지 유형, URI 주소 및 포트 번호와 같은 정보를 연결하려는 구독자에게 배포한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_publisher_info.png&quot; title=&quot;퍼블리셔 정보 제공&quot; /&gt;&lt;br /&gt;
출처:[ROS_Robot_Programming_EN]&lt;/p&gt;

&lt;h3 id=&quot;5-서브스크라이버-노드의-연결-요청&quot;&gt;(5) 서브스크라이버 노드의 연결 요청&lt;/h3&gt;

&lt;p&gt;서브스크라이버 노드는 마스터로부터 수신 된 퍼블리셔 정보에 바탕으로 퍼블리셔 노드에 직접 연결을 요청한다. 요청 절차 중에 서브스크라이버 노드는 노드 이름, 토픽 이름 및 메시지 유형과 같은 정보를 퍼블리셔 노드에 전송한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_subscriber_connection.png&quot; title=&quot;서브스크라이버 노드의 연결 요청&quot; /&gt;&lt;br /&gt;
출처:[ROS_Robot_Programming_EN]&lt;/p&gt;

&lt;h3 id=&quot;6-퍼블리셔-노드의-연결-응답&quot;&gt;(6) 퍼블리셔 노드의 연결 응답&lt;/h3&gt;

&lt;p&gt;퍼블리셔 노드는 서브스크라이버 노드의 연결 요청에 대한 응답으로 TCP 서버의 URI 주소와 포트 번호를 보낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_publisher_response.png&quot; title=&quot;퍼블리셔 노드의 연결 응답&quot; /&gt;&lt;br /&gt;
출처:[ROS_Robot_Programming_EN]&lt;/p&gt;

&lt;h3 id=&quot;7-tcpros-connection&quot;&gt;(7) TCPROS Connection&lt;/h3&gt;

&lt;p&gt;서브스크라이버 노드는 TCPROS를 사용하여 퍼블리셔 노드에 대한 클라이언트를 생성하고 퍼블리셔 노드에 연결한다. 이 시점에서 노드 간 통신은 TCPROS라는 TCP/IP 기반 프로토콜을 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_tcpros_connection.png&quot; title=&quot;TCPROS 연결&quot; /&gt;&lt;br /&gt;
출처:[ROS_Robot_Programming_EN]&lt;/p&gt;

&lt;h3 id=&quot;8-메시지-전송&quot;&gt;(8) 메시지 전송&lt;/h3&gt;

&lt;p&gt;퍼블리셔 노드는 미리 설정된 메시지를 서브스크라이버 노드로 송신하게 된다. 이 둘 사이의 연결은 TCPROS 연결 방식을 활용하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_message_trasmit.png&quot; title=&quot;TCPROS 메시지 전송&quot; /&gt;&lt;br /&gt;
출처:[ROS_Robot_Programming_EN]&lt;/p&gt;

&lt;h2 id=&quot;3-서비스-메시지-통신의-흐름&quot;&gt;3. 서비스 메시지 통신의 흐름&lt;/h2&gt;

&lt;p&gt;서비스에는 두 노드를 중심으로 통신이 이루어 진다.&lt;/p&gt;

&lt;p&gt;서비스 클라이언트 : 서비스 요청 및 응답 받기
서비스 서버 : 서비스를 받고 지정된 작업을 실행하고 응답을 반환&lt;/p&gt;

&lt;p&gt;서비스 서버와 클라이언트 간의 연결은 위에서 설명한 퍼블리셔 및 서브스크라이버의 TCPROS 연결과 동일하다. 토픽(Topic)과 달리 요청(request) 및 응답(response)이 성공하면 서비스가 연결을 종료합니다. 추가 요청이 필요한 경우 연결 절차를 다시 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_service_ex.png&quot; title=&quot;서비스의 메시지 전송&quot; /&gt;&lt;br /&gt;
출처:[ROS_Robot_Programming_EN]&lt;/p&gt;

&lt;h2 id=&quot;4-액션-메시지-통신의-흐름&quot;&gt;4. 액션 메시지 통신의 흐름&lt;/h2&gt;

&lt;p&gt;액션은 피드백이라는 추가 메시지가 있는 서비스 요청 및 응답과 유사하게 보일 수 있다.
피드백 메시지는 요청(목표)과 응답(결과) 사이에 중간 결과를 제공하지만 실제로는 토픽과 비슷하다. 실제로 ‘rostopic’명령을 사용하여 주제를 나열하는 경우 액션에 사용되는 목표, 상태, 취소, 결과 및 피드백과 같은 5 가지 토픽이 있다. 액션 서버와 클라이언트 간의 연결은 퍼블리셔 및 서브스크라이버의 TCPROS 연결과 유사하지만 사용법이 약간 다르다. 예를 들어, 액션 클라이언트가 취소 명령을 보내거나 서버가 결과 값을 보내면 연결이 종료된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_action_ex.png&quot; title=&quot;액션의 메시지 전송&quot; /&gt;&lt;br /&gt;
출처:[ROS_Robot_Programming_EN]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ROS 로봇 프로그래밍 책이 한국어판은 3만 2천원에 판매하는데, 영문 판은 무료로 다운로드 가능하다. 번역비용 치고 좀 비싸다는 생각이 들긴 하지만, 한 권정도 갖고 있으면 괜찮을 듯 싶다. 관련된 내용은 대체로 wiki.ros.org에서 확인할 수 있는 듯 하다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Kiho Lee</name></author><category term="ROS" /><category term="메시지통신" /><category term="통신프로세스" /><category term="메시지" /><summary type="html">1. 들어가며</summary></entry><entry><title type="html">05.ROS 용어 정리 및 개념</title><link href="http://localhost:4000/categories/ros/ROS-05-ros-words.html" rel="alternate" type="text/html" title="05.ROS 용어 정리 및 개념" /><published>2019-12-10T00:00:00+00:00</published><updated>2019-12-10T00:00:00+00:00</updated><id>http://localhost:4000/categories/ros/ROS-05-ros-words</id><content type="html" xml:base="http://localhost:4000/categories/ros/ROS-05-ros-words.html">&lt;h2 id=&quot;1-ros-란&quot;&gt;1. ROS 란?&lt;/h2&gt;

&lt;p&gt;ROS는 로봇의 응용프로그램을 개발하기 위한 운영체제와 같은 로봇 소프트웨어 플랫폼이다. ROS는 로봇 응용프로그램을 개발할 때 필요한 하드웨어 추상화, 디바이스 제어, 센싱 및 인식, SLAM 등 다양한 기능을 라이브러리 형태로 제공하고 있으며, 디버깅 도구 및 시뮬레이션 도구를 제공하는 메타 OS이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_communication.png&quot; title=&quot;ROS 개념&quot; /&gt;
출처:&lt;a href=&quot;https://robertchoi.gitbook.io/ros/untitled-2&quot;&gt;ROS 하루에 입문하기&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;메타 OS는 사실 실제로 존재하는 말이기 보다는 ROS를 설명하기 위해서 등장한 용어라고 보여진다. Linux, Windos, OS X와 같은 다른 운영체제간 통신을 기반으로 이기종 디바이스 컨트롤이 가능하게 만든 것이 ROS이기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-마스터&quot;&gt;2. 마스터&lt;/h2&gt;

&lt;p&gt;마스터(master)란 노드와 노드사이를 연결하여 메시지 통신이 가능하게 하는 일종의 커멘드 센터이다. 흔히 네임 서버로 비교하여 설명을 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roscore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어를 실행하여 마스터를 실행하고, 각각의 패키지 노드들을 연결하여 ROS프로그램이 동작하게 된다.
또한, 마스터는 마스터에 접속한 슬레이브들과의 접속상태를 지속적으로 유지하는 것이 아니라 HTTP기반의 프로토콜인 XMLRPC(XML-Remote Procedure Call)를 이용하여 슬레이브들과 통신한다.&lt;/p&gt;

&lt;p&gt;로봇은 매우 복잡한 센서와 모듈들이 통합되어 있어서, 통신을 지속적으로 연결하고 있으면 리소스의 낭비가 심각해질 수 있지만, 이러한 통신 방식은 자원을 효율적으로 활용할 수 있도록 돕니다. 게다가 XMLRPC는 매우 가볍고, 다양한 프로그래밍 언어를 지원하기 때문에 여러 종류의 하드웨어와 언어를 지원해야 하는 ROS에 매우 적합하다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;설정시 유의해야 할 점은 ROS를 구동하면서 마스터는 사용자가 정해 놓은 ROS_MASTER_URI 변수에 기재된 URI 주소와 포트를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_communication3.jpeg&quot; title=&quot;ROS 통신 개념&quot; /&gt;
출처:&lt;a href=&quot;https://robertchoi.gitbook.io/ros/untitled-2&quot;&gt;ROS 하루에 입문하기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-노드&quot;&gt;3. 노드&lt;/h2&gt;

&lt;p&gt;노드(node)는 ROS에서 실행되는 최소 단위의 프로세서를 지칭한다. 즉, 최소 단위의 실행 가능한 프로그램으로 반드시 roscore가 등록된 이후에 실행을 시켜야 한다.
모든 프로그램에서 권장하는 방법이겠지만, 프로그램을 모듈단위로 잘 구성하여 재사용성을 높이도록 하는 것이 좋은 노드를 구성하는 방법이 될 것이다. 예를 들면, 로봇을 구동하기 위해서 필요한 모터와 엔코더 등을 각각 세분화하여 노드로 구성하는 것을 권장한다.&lt;/p&gt;

&lt;p&gt;노드에는 다양한 정보가 들어간다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;노드 명칭&lt;/li&gt;
  &lt;li&gt;퍼블리셔(Publisher), 서브스크라이버(Subscriber), 서비스 서버(Service server), 서비스 클라이언트(Service Client) 구분&lt;/li&gt;
  &lt;li&gt;사용되는 토픽 및 서비스 이름&lt;/li&gt;
  &lt;li&gt;메시지 형태&lt;/li&gt;
  &lt;li&gt;URI 주소&lt;/li&gt;
  &lt;li&gt;포트 번호 등&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;노드는 마스터와 통신할 때 XMLRPC를 활용하고, 노드간에도 XMLRPC 혹은 TCP/IP 통신 방식을 활용한 TCPROS를 이용한다.&lt;/p&gt;

&lt;h2 id=&quot;4-패키지&quot;&gt;4. 패키지&lt;/h2&gt;

&lt;p&gt;패키지(Package)는 ROS를 구성하는 기본 단위가 된다. 
ROS의 응용프로그램은 패키지 단위로 개발되며 패키지는 최소한 하나 이상의 노드를 포함하거나 다른 패키지의 노드를 싱행하기 위한 설정파일 및 의존성 라이브러리, 데이터 셋 등이 있을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;5-메타패키지&quot;&gt;5. 메타패키지&lt;/h2&gt;

&lt;p&gt;메타패키지(metapackage)는 공통된 목적을 가진 패키지 집합이다. 대단위 기능을 수행하는 프로그램의 경우 단일 패키지로 불가능하고 복수 개의 패키지를 연동 실행하여 수행 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;6-메시지&quot;&gt;6. 메시지&lt;/h2&gt;

&lt;p&gt;노드는 메시지(message)를 통해 노드 간의 데이터를 주고 받을 수 있다. 메시지의 종류는 integer, floating point, boolean과 같은 변수 형태에서 메시지를 품은 메시지이거나 배열도 메시지로 송수신이 가능하다.&lt;/p&gt;

&lt;p&gt;메시지의 통신 방식은 TCPROS, UDPROS 등의 방식이 있다.&lt;/p&gt;

&lt;p&gt;단방향 메시지 송수신 방식을 토픽(Topic)이라고 한다.
양방향 메시지 송수신 방식을 서비스(Service)라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;7-토픽&quot;&gt;7. 토픽&lt;/h2&gt;

&lt;p&gt;토픽(topic)은 로봇 혹은 로봇 연관 시스템에서 작업을 수행하기 위한 작업 내용(ROS프로그래밍 책에서는 ‘이야깃거리’라 칭함)을 말한다고 보면 된다. 퍼블리셔(Publisher) 노드가 하나의 작업 내용에 대해 마스터에 등록한 후, 이 작업 내용에 대한 메시지를 퍼블리시(출판 혹은 발송)하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_topic.jpeg&quot; title=&quot;토픽 개념&quot; /&gt;
출처:&lt;a href=&quot;https://robertchoi.gitbook.io/ros/untitled-2&quot;&gt;ROS 하루에 입문하기&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;용어나 말이 굉장히 낯설게 느껴질 수 있다. ROS를 설계자가 나름 통신 프로토콜(일종의 통신 약속)을 규정하기 위해서 들고 나온 개념이라고 보면 된다. 이러한 용어는 자주 보고 쓰다보면 익숙해질 수 있을 것이라고 생각한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 작업 내용을 구독해주시는 열혈 독자가 있는데, 이를 서브스크라이버(subscriber)라고 한다. 각각 노드별로 역할이 있고,명칭이 있다고 보면된다.&lt;/p&gt;

&lt;h2 id=&quot;8-퍼블리시-및-퍼블리셔&quot;&gt;8. 퍼블리시 및 퍼블리셔&lt;/h2&gt;

&lt;p&gt;퍼블리시(publish)는 작업 내용에 해당하는 토픽의 메시지 형태의 데이터를 발송(송신)하는 것을 말한다. 퍼블리셔(publisher)는 이러한 퍼블리시(publish)라는 행위를 하는 노드를 말한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;골키퍼가 공을 잡고, 다른 선수들은 공을 발로 찬다. 이렇게 하면 말이 되지만, 공격수가 공을 잡는다 하면 말도 안되는 행위가 될 것이다. 머 이렇게 일단 이해해보자. 사실 어려운 내용도 아니니 말이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;퍼블리셔는 자신의 노드 정보와 토픽으로 보낼 정보 등을 마스터 ROSCORE에 등록한다. 그리고 subscriber를 할 노드에게 메시지를 보낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_publisher.png&quot; title=&quot;퍼블리셔 개념&quot; /&gt;
&lt;br /&gt;
출처:&lt;a href=&quot;https://m.blog.naver.com/PostView.nhn?blogId=0323lena&amp;amp;logNo=220357703221&amp;amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F&quot;&gt;김빠진사이다&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;9-서브스크라이브-및-서브스크라이버&quot;&gt;9. 서브스크라이브 및 서브스크라이버&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;야구에 투수가 있으면, 당연히 포수가 있고, 타자도 있다. 그렇지만, 토픽(TOPIC)의 개념에서 보면 투수와 포수만 있다고 볼 수 있다. 야구공은 메시지라고 볼 수 있을 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_subscriber.png&quot; title=&quot;서브스크라이버 개념&quot; /&gt;
&lt;br /&gt;
출처:&lt;a href=&quot;https://wyvernsstory.tistory.com/entry/%EA%B3%B5%EA%B0%90%E5%85%B1%E6%84%9F-W-%EC%95%BC%EA%B5%AC%EC%9E%A5%EC%97%90%EC%84%9C-%EA%B7%B8%EB%A6%AC%EB%8A%94-%EB%82%98%EC%9D%98-%EB%AF%B8%EB%9E%98-SK-%ED%8F%AC%EC%88%98-%EC%9D%B4%EC%9C%A4%EC%9E%AC&quot;&gt;sk와이번스&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;서브스크라이버는 퍼블려서와 같은 프로세스를 따른다. 먼저 마스터에 자신의 정보를 등록하고, 서브스크라이브를 수행하기 위한 토픽을 포함한 자신의 정보들을 등록하고, 해당 토픽을 퍼블리시하는 퍼블리셔 노드의 정보를 마스터로 부터 받게 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;야구를 예로 들어서 설명을 하지만, 다수의 퍼블리셔가 있을 수 있고, 다수의 서브스크라이버가 있을 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;토픽 개념의 통신방식(퍼블리시와 서브스크라이브)은 비동기 방식이라서 전송이 필요할 때만, 데이터를 보낼 수 있기 때문에 매우 효율적인 방식이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;보통 센서로부터 데이터를 받을 때, 패시브한 방식으로 데이터를 받기만 한다. 물론 일부 I2C 통신으로 COMMAND를 날리는 센서도 있긴 하지만, 대부분의 패시브 센서 (온도, 습도, 조도 등)는 데이터를 보내는 핀(Tx)만 활용하기 때문에 이러한 센서는 토픽 방식을 쓰면 매우 효율적이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;10-서비스service&quot;&gt;10. 서비스(service)&lt;/h2&gt;

&lt;p&gt;서비스(service)는 작업 내용(특수 목적 포함)에 대해 서비스 클라이언트(service client)와 서비스 서버(service server)간의 양방향 동기적 통신을 말한다. 클라이언트는 요청하고, 서버는 응답하게된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;흔히 대화를 주고 받는 만담(conversation)과는 좀 다르다고 볼 수 있는데, 작업 내용에 대한 메시지를 보내고 그 결과를 주는 형식이라고 보면 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_service.jpeg&quot; title=&quot;서비스 개념&quot; /&gt;
출처:&lt;a href=&quot;https://robertchoi.gitbook.io/ros/untitled-2&quot;&gt;ROS 하루에 입문하기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-서비스-서버service-server&quot;&gt;11. 서비스 서버(service server)&lt;/h2&gt;

&lt;p&gt;서비스 서버(service server)는 서비스 클라이언트(service client)로 부터 작업 내용의 요청(메시지;request)를 받고, 작업을 한 후에 작업 내용의 완료결과(메시지)를 응답(메시지;response)하게 된다. 따라서, 서비스 서버가 응답 주체(노드)가 된다.&lt;/p&gt;

&lt;h2 id=&quot;12-서비스-클라이언트service-client&quot;&gt;12. 서비스 클라이언트(service client)&lt;/h2&gt;

&lt;p&gt;서비스 클라이언트(service client)는 작업 내용의 요청(메시지;request)을 서비스 서버(service server)로 보내고 그 결과 응답(메시지;response)를 받는 요청 주체(노드)가 된다.&lt;/p&gt;

&lt;h2 id=&quot;13-액션action&quot;&gt;13. 액션(action)&lt;/h2&gt;

&lt;p&gt;액션(action)은 서비스처럼 양방향을 통신방식이지만, 중간 중간에 작업 상황을 피드백을 해주는 처리가 들어간 통신 방식이라고 할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;파일을 옮기기 하면, 파일이 이동하는 Progress bar가 보인다. 이러한 기능도 액션의 개념과 유사하다고 볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;액션도 서비스와 비슷한 면이 있지만, 요청과 응답을 달리 표현한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;목표(goal)&lt;/li&gt;
  &lt;li&gt;결과(result)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;액션의 목표를 정하는 액션 클라이언트(action client)와 목표에 따라 임무를 수행하고, 임무가 끝나기 전까지 계속 피드백을 보내는 액션 서버(action server)가 서로 비동기 양방향 통신을 하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;14-액션-서버action-server&quot;&gt;14. 액션 서버(action server)&lt;/h2&gt;

&lt;p&gt;액션 서버(action server)는 앞서 설명한 바와 같이 액션 클라이언트로 부터 목표를 전달 받고, 해당 목표를 수행하는 노드(주체)가 된다. 또한, 목표(임무)를 완료하기 전까지 중간 중간 액션 클라이언트로 부터 받은 목표에 맞게 피드백을 보내주게 된다.&lt;/p&gt;

&lt;h2 id=&quot;15-액션-클라이언트action-client&quot;&gt;15. 액션 클라이언트(action client)&lt;/h2&gt;

&lt;p&gt;액션 클라이언트(action client)는 목표를 출력하고, 액션 서버에서 보내는 결과와 피드백을 입력받는 노드이다. 액션 클라이언트가 목표를 액션 서버에 보내고 피드백을 받다가 취소명령을 보낼 수 있고, 완료 메시지를 액션 서버로부터 받으면 다음 명령을 보낼 수도 있다.&lt;/p&gt;

&lt;h2 id=&quot;16-파라미터&quot;&gt;16. 파라미터&lt;/h2&gt;

&lt;p&gt;ROS에서 parameter(매개변수)는 보통 노드에서 활용되는 파라미터를 말하게 된다. 예를 들면, 윈도우에서 활용되는 &lt;strong&gt;*.ini&lt;/strong&gt;파일이라고 볼 수도 있을 것 같다.
보통은 디폴트(default) 값을 활용하게 되는 데, 상황에 따라 외부에서 설정 값을 밀어 넣을 수 있기 때문에 실시간 변경이 매우 용이하고 유용한 기능이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;외부 장치와 연결되는 USB포트, 카메라 캘리브레이션 값, 모터 속도 등등&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;17-파라미터-서버&quot;&gt;17. 파라미터 서버&lt;/h2&gt;

&lt;p&gt;파라미터 서버(parameter server)는 패키지에서 파라미터를 사용할 때, 이 곳에 등록하여 활용한다. 이는 마스터의 기능 중 하나이기도 하다.&lt;/p&gt;

&lt;h2 id=&quot;18-catkin&quot;&gt;18. Catkin&lt;/h2&gt;

&lt;p&gt;캐킨(Catkin)은 ROS의 빌드 시스템이다. ROS의 빌드 시스템은 기본적으로 CMake(Cross Platform Make)를 이용하고 있어서 패키지 폴더에 CMakeLists.txt라는 파일에 빌드를 하기 위한 다양한 설정 내용들을 작성해야 한다. ROS에서 CMake를 ROS에 맞게 변경하여 ROS만의 특ㄹ화된 Catkin Build System을 구축하였다.
캐킨 빌드 스스템은 ROS와 관련된 빌드, 패키지 관리, 패키지 간의 의존관계 등을 편리하게 사용할 수 있게 한다.&lt;/p&gt;

&lt;h2 id=&quot;19-roscore&quot;&gt;19. roscore&lt;/h2&gt;

&lt;p&gt;roscore는 ROS 마스터를 실행하는 명령어이다. 같은 네트워크라면 다른 컴퓨터에서 실행해도 된다. ROS2는 기본적으로 멀티네트워크를 지원한다고 하지만, ROS는 roscore와 같은 네트워크 상에 있어야 통신이 가능하다.&lt;/p&gt;

&lt;p&gt;네트워크 설정은 환경설정 파트에서 했던 부분의 IP주소를 참조하면 된다.&lt;/p&gt;

&lt;p&gt;기존에 설정했던 내용&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# Set ROS Network&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ROS_HOSTNAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;192.168.0.44
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ROS_MASTER_URI&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;ROS_HOSTNAME&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;:11311
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;만약 특별한 설정이 없으면, localhost를 활용하게 되고, 포트번호는 11311을 활용하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_communication2.jpeg&quot; title=&quot;ROS 통신 개념&quot; /&gt;
출처:&lt;a href=&quot;https://robertchoi.gitbook.io/ros/untitled-2&quot;&gt;ROS 하루에 입문하기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;20-rosrun&quot;&gt;20. rosrun&lt;/h2&gt;

&lt;p&gt;rosrun은 ROS의 기본 실행 명령어이다. 패키지에서 하나의 노드를 실행할 때 사용하게 된다. 
거북이 움직이는 테스트를 해본 경험이 있다면 아래 명령어를 기억할 것이다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rosrun turtlesim turtlesim_node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;노드는 실행되면서 ROS_HOSTNAME에 URI의 주소를 활용하게 되고, 포트번호는 임의로 지정되게 된다.&lt;/p&gt;

&lt;h2 id=&quot;21-roslaunch&quot;&gt;21. roslaunch&lt;/h2&gt;

&lt;p&gt;ROS를 조금이라도 실행해 본 사람이라면, 알겠지만 굉장히 많은 터미널 창을 열어두어야 할 것이다. 만약 여러 노드를 실행한다면, 해당하는 노드만큼 터미널을 실행해야 될테지만, 만약 한 번에 많은 노드를 실행한다면 상당히 피로도 높은 작업이 될 수 있다.
roslaunch는 여러 노드를 실행하는 개념이라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;– 지원 옵션 –&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;복수 개의 노드 실행&lt;/li&gt;
  &lt;li&gt;패키지 파라미터 설정&lt;/li&gt;
  &lt;li&gt;노드 이름 변경&lt;/li&gt;
  &lt;li&gt;노드 네임스페이스 설정&lt;/li&gt;
  &lt;li&gt;ROS_ROOT 및 ROS_PACKAGE_PATH 설정&lt;/li&gt;
  &lt;li&gt;환경변수 변경&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;roslaunch의 실행 내용은 *.launch 파일을 사용하여 실행 노드에 대한 설정을 해주는데 XML(Extensible Markup Language)을 이용해서 옵션을 설정하게된다.&lt;/p&gt;

&lt;h2 id=&quot;22-bag&quot;&gt;22. bag&lt;/h2&gt;

&lt;p&gt;ROS에서 매우 중요한 기능중에 하나로 보여지는 bag은 메시지를 저장한 파일 포맷(*.bag)이다. 이 파일을 이용하여 로봇을 활용한 테스트 상황을 구현할 수 있다. 그러면 실제 실험환경을 재구축 하지 않아도 &lt;strong&gt;rosbag play *.bag&lt;/strong&gt;를 이용해서 센서의 값들을 확인해 볼 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;rosbag의 기록, 재생의 기능을 활용하면 반복되는 프로그램 수정이 많은 알고리즘 개발에 매우 유용하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;23-ros-wiki&quot;&gt;23. ROS Wiki&lt;/h2&gt;

&lt;p&gt;ROS에 관련된 개념과 활용방법에 대하여 설명을 제공하는 위키 기반(&lt;strong&gt;http://wiki.ros.org&lt;/strong&gt;)의 페이지이다. ROS에 관련된 강좌나 책을 찾아보는 것도 좋지만, 가장 기본이 되는 메뉴얼은 ROS Wiki이다.&lt;/p&gt;

&lt;h2 id=&quot;24-리포지토리&quot;&gt;24. 리포지토리&lt;/h2&gt;

&lt;p&gt;공개 패키지는 ROS Wiki에서 리포지토리의 주소를 명시하고 있다. 리포지토리는 패키지가 저장된 웹상의 URL이며, svn, hg, git 등의 소스 관리 시스템을 이요하여 이슈, 개발, 내려받기 등을 관리하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;25-그래프&quot;&gt;25. 그래프&lt;/h2&gt;

&lt;p&gt;ROS에서 실행한 다양한 노드와 통신 관계(토픽, 서비스, 액션)을 그래프(graph)로 시각화하여 직관적으로 관계를 파악 할 수 있도로 돕는 시각화 도구이다.&lt;/p&gt;

&lt;h2 id=&quot;26-네임&quot;&gt;26. 네임&lt;/h2&gt;

&lt;p&gt;노드, 파라미터, 토픽, 서비스, 액션 등 모두 네임(name)을 갖고 있고, 이를 활용하게 된다. 각 네임은 ROS 마스터에 등록하고, 통신을 할 때 이름을 기반으로 검색하거나 메시지를 전송하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;27-클라이언트-라이브러리&quot;&gt;27. 클라이언트 라이브러리&lt;/h2&gt;

&lt;p&gt;ROS는 개발 언어의 의존성을 줄이기 위한 방법으로 클라이언트 라이브러리(client library)로 각종 언어의 개발환경을 제공하고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt; - roscpp&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Python&lt;/strong&gt; - rospy&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Lips&lt;/strong&gt; - roslips&lt;/li&gt;
  &lt;li&gt;Java - rosjava&lt;/li&gt;
  &lt;li&gt;Lua - roslua&lt;/li&gt;
  &lt;li&gt;.NET - roscs&lt;/li&gt;
  &lt;li&gt;EusLisp - roseus&lt;/li&gt;
  &lt;li&gt;R - rosR&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;28-uri&quot;&gt;28. URI&lt;/h2&gt;

&lt;p&gt;URI(Uniform Resource Identifier, 통합 자원 식별자)는 인터넷에 있는 자원을 나타내는 유일한 주소이다.&lt;/p&gt;

&lt;h2 id=&quot;29-md5&quot;&gt;29. MD5&lt;/h2&gt;

&lt;p&gt;MD5(Message-Digest algorithm 5)는 128bit 암호화 해시 함수이다. 주로 프로그램이나 파일이 송신된 원본과 같은지 무결성을 검사하기 위해서 활용된다.&lt;/p&gt;

&lt;h2 id=&quot;30-rpc&quot;&gt;30. RPC&lt;/h2&gt;

&lt;p&gt;RPC(Remote Procedure Call)란 &lt;strong&gt;원격 컴퓨터의 프로그램이 다른 컴퓨터에 있는 서브 프로그램(Procedure)을 불러내는(Call) 것&lt;/strong&gt;을 의미한다. TCP/IP, IPX 등의 전송 프로토콜 기술을 활용한다.&lt;/p&gt;

&lt;h2 id=&quot;31-xml&quot;&gt;31. XML&lt;/h2&gt;

&lt;p&gt;XML(Extensible Markup Language)은 W3C에서 다른 특수 목적의 마크텁 언어를 만드는 용도로 권장하는 다목적 마크업 언어(markup language)이다.
ROS에서 *.launch, *.urdf, package.xml 등 다양한 부분에서 사용되고 있다.&lt;/p&gt;

&lt;h2 id=&quot;32-xmlrpc&quot;&gt;32. XMLRPC&lt;/h2&gt;

&lt;p&gt;XMLRPC(XML-Remote Procedure Call)는 RPC 프로토콜의 일종으로, 인코딩 형식에서는 XML을 채택하고, 전송방식은 접속상태를 유지하지 않고 점검하지 않는 요청과 응답 방식의 HTTP 프로토콜을 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;33-tcpip&quot;&gt;33. TCP/IP&lt;/h2&gt;

&lt;p&gt;TCP(Transmission Control Protocol)는 전송 제어 프로토콜이다.
인터넷 프로토콜 계층으로 보면 IP(Internet Protocol)를 기반으로 전송 제어 프로토콜인 TCP를 사용하여 데이터의 전달을 보증하고 보낸 순서대로 송수신한다.&lt;/p&gt;

&lt;p&gt;TCPROS 메시지 및 서비스에서 사용되는 TCP/IP 기반의 메시지 방식을 TCPROS라고 하고 UDPROS는 UDP기반이다.&lt;/p&gt;

&lt;h2 id=&quot;34-cmakeliststxt&quot;&gt;34. CMakeLists.txt&lt;/h2&gt;

&lt;p&gt;ROS의 빌드 시스템인 Catkin은 기본적으로 CMake를 이용하고 있고, CMakeLists.txt는 빌드를 할 데이터의 빌드 환경을 기술하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;35-packagexml&quot;&gt;35. package.xml&lt;/h2&gt;

&lt;p&gt;패키지의 정보를 담은 XML 파일로 패키지의 이름, 저작권, 라이선스, 의존성 패키지 등을 기술하고 있다.&lt;/p&gt;

&lt;p&gt;출처:[ROS 로봇프로그래밍 저)표윤석, 조한철, 정려운, 임태훈]&lt;/p&gt;

&lt;h2 id=&quot;36-tftranform&quot;&gt;36. TF(Tranform)&lt;/h2&gt;

&lt;p&gt;구동하는 로봇의 각 조인트(joint)들의 상대좌표 변환으로 물리적 이미지를 표현
트리(tree) 형태로 조인트들 간의 관계도를 표시함&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ros/ros_TF.jpeg&quot; title=&quot;TF 개념&quot; /&gt;
출처:&lt;a href=&quot;https://robertchoi.gitbook.io/ros/untitled-2&quot;&gt;ROS 하루에 입문하기&lt;/a&gt;&lt;/p&gt;</content><author><name>Kiho Lee</name></author><category term="ROS" /><category term="words" /><category term="concept" /><summary type="html">1. ROS 란?</summary></entry></feed>